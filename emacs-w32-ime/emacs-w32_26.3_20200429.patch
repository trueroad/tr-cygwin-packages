diff -r -u emacs-26.3/configure emacs-26.3/configure
--- emacs-26.3/configure	2019-08-22 07:43:48.000000000 +0900
+++ emacs-26.3/configure	2020-04-22 21:40:49.510278100 +0900
@@ -1535,6 +1535,7 @@
 docdir
 oldincludedir
 includedir
+runstatedir
 localstatedir
 sharedstatedir
 sysconfdir
@@ -1719,6 +1720,7 @@
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
+runstatedir='${localstatedir}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
@@ -1971,6 +1973,15 @@
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
 
+  -runstatedir | --runstatedir | --runstatedi | --runstated \
+  | --runstate | --runstat | --runsta | --runst | --runs \
+  | --run | --ru | --r)
+    ac_prev=runstatedir ;;
+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
+  | --run=* | --ru=* | --r=*)
+    runstatedir=$ac_optarg ;;
+
   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
     ac_prev=sbindir ;;
   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
@@ -2108,7 +2119,7 @@
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
+		libdir localedir mandir runstatedir
 do
   eval ac_val=\$$ac_var
   # Remove trailing slashes.
@@ -2261,6 +2272,7 @@
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
@@ -11065,6 +11077,12 @@
 
 $as_echo "#define HAVE_NTGUI 1" >>confdefs.h
 
+
+$as_echo "#define USE_W32_IME 1" >>confdefs.h
+
+
+$as_echo "#define IME_UNICODE 1" >>confdefs.h
+
   if test "$with_toolkit_scroll_bars" = "no"; then
     as_fn_error $? "Non-toolkit scroll bars are not implemented for w32 build." "$LINENO" 5
   fi
@@ -12025,7 +12043,7 @@
 
 ### Use -lrsvg-2 if available, unless '--with-rsvg=no' is specified.
 HAVE_RSVG=no
-if test "${HAVE_X11}" = "yes" || test "${HAVE_NS}" = "yes" || test "${opsys}" = "mingw32"; then
+if test "${HAVE_X11}" = "yes" || test "${HAVE_NS}" = "yes" || test "${HAVE_W32}" = "yes"; then
   if test "${with_rsvg}" != "no"; then
     RSVG_REQUIRED=2.14.0
     RSVG_MODULE="librsvg-2.0 >= $RSVG_REQUIRED"
diff -r -u emacs-26.3/configure.ac emacs-26.3/configure.ac
--- emacs-26.3/configure.ac	2019-08-22 07:25:23.000000000 +0900
+++ emacs-26.3/configure.ac	2020-04-22 21:40:15.079302900 +0900
@@ -2070,6 +2070,8 @@
 XARGS_LIMIT=
 if test "${HAVE_W32}" = "yes"; then
   AC_DEFINE(HAVE_NTGUI, 1, [Define to use native MS Windows GUI.])
+  AC_DEFINE(USE_W32_IME, 1, [Define to use w32 ime.])
+  AC_DEFINE(IME_UNICODE, 1, [Define to use w32 ime unicode.])
   if test "$with_toolkit_scroll_bars" = "no"; then
     AC_MSG_ERROR([Non-toolkit scroll bars are not implemented for w32 build.])
   fi
@@ -2498,7 +2500,7 @@
 
 ### Use -lrsvg-2 if available, unless '--with-rsvg=no' is specified.
 HAVE_RSVG=no
-if test "${HAVE_X11}" = "yes" || test "${HAVE_NS}" = "yes" || test "${opsys}" = "mingw32"; then
+if test "${HAVE_X11}" = "yes" || test "${HAVE_NS}" = "yes" || test "${HAVE_W32}" = "yes"; then
   if test "${with_rsvg}" != "no"; then
     RSVG_REQUIRED=2.14.0
     RSVG_MODULE="librsvg-2.0 >= $RSVG_REQUIRED"
diff -r -u emacs-26.3/lisp/image-mode.el emacs-26.3/lisp/image-mode.el
--- emacs-26.3/lisp/image-mode.el	2019-02-20 22:44:42.000000000 +0900
+++ emacs-26.3/lisp/image-mode.el	2019-12-18 23:51:23.097180400 +0900
@@ -758,7 +758,7 @@
 	 (edges (and (null image-transform-resize)
 		     (window-inside-pixel-edges
 		      (get-buffer-window (current-buffer)))))
-	 (type (if (fboundp 'imagemagick-types)
+	 (type (if (image--imagemagick-wanted-p filename)
 		   'imagemagick
 		 (image-type file-or-data nil data-p)))
          ;; :scale 1: If we do not set this, create-image will apply
@@ -805,6 +805,13 @@
     (if (called-interactively-p 'any)
 	(message "Repeat this command to go back to displaying the file as text"))))
 
+(defun image--imagemagick-wanted-p (filename)
+  (and (fboundp 'imagemagick-types)
+       (not (eq imagemagick-types-inhibit t))
+       (not (and filename (file-name-extension filename)
+		 (memq (intern (upcase (file-name-extension filename)) obarray)
+		       imagemagick-types-inhibit)))))
+
 (defun image-toggle-hex-display ()
   "Toggle between image and hex display."
   (interactive)
diff -r -u emacs-26.3/lisp/image.el emacs-26.3/lisp/image.el
--- emacs-26.3/lisp/image.el	2019-06-12 19:50:42.000000000 +0900
+++ emacs-26.3/lisp/image.el	2019-08-29 22:10:56.418020200 +0900
@@ -243,6 +243,15 @@
     (nconc (list image-directory)
            (delete image-directory (copy-sequence (or path load-path))))))
 
+;;;###autoload
+(defcustom image-fit-option-alist 'never
+  "Alist of (IMAGE-TYPE . FIT-OPTION) pairs used by image loader to specify image size.
+the FIT-OPTION is one of 'never, 'frame, 'width-or-height, 'width or 'height.
+Note: All image loaders are not supporting this `fit' capability.
+"
+  :type 'sexp
+  :initialize 'custom-initialize-default
+  :group 'image)
 
 ;; Used to be in image-type-header-regexps, but now not used anywhere
 ;; (since 2009-08-28).
diff -r -u emacs-26.3/lisp/loadup.el emacs-26.3/lisp/loadup.el
--- emacs-26.3/lisp/loadup.el	2019-01-07 23:26:06.000000000 +0900
+++ emacs-26.3/lisp/loadup.el	2019-08-29 22:10:56.418020200 +0900
@@ -286,6 +286,7 @@
       (when (eq system-type 'windows-nt)
         (load "w32-fns")
         (load "ls-lisp")
+        (load "international/w32-ime")
         (load "dos-w32"))))
 (if (eq system-type 'ms-dos)
     (progn
diff -r -u emacs-26.3/lisp/startup.el emacs-26.3/lisp/startup.el
--- emacs-26.3/lisp/startup.el	2019-01-07 23:26:06.000000000 +0900
+++ emacs-26.3/lisp/startup.el	2019-08-29 22:10:56.418020200 +0900
@@ -605,6 +605,7 @@
     (put 'user-full-name 'standard-value
 	 (list (default-value 'user-full-name)))
     ;; If the PWD environment variable isn't accurate, delete it.
+    (set-language-environment "japanese")
     (let ((pwd (getenv "PWD")))
       (and (stringp pwd)
 	   ;; Use FOO/., so that if FOO is a symlink, file-attributes
@@ -1697,7 +1698,7 @@
 (defun fancy-splash-head ()
   "Insert the head part of the splash screen into the current buffer."
   (let* ((image-file (fancy-splash-image-file))
-	 (img (create-image image-file))
+	 (img (create-image image-file nil nil :fit 'never))
 	 (image-width (and img (car (image-size img))))
 	 (window-width (window-width)))
     (when img
diff -r -u emacs-26.3/src/buffer.c emacs-26.3/src/buffer.c
--- emacs-26.3/src/buffer.c	2019-07-26 04:41:28.000000000 +0900
+++ emacs-26.3/src/buffer.c	2019-08-29 22:10:56.433639700 +0900
@@ -374,6 +374,19 @@
     error ("No buffer named %s", SDATA (spec));
   error ("Invalid buffer argument");
 }
+
+/* patch20101016 */
+#ifdef WINDOWSNT
+#include <mbstring.h>
+#define LAST_CHAR(buf,len) ((len) < 1 ? '\0' : *_mbsdec((buf), (buf) + (len)))
+#define STRINC(p) _mbsinc(p)
+#define STRDEC(start, p) _mbsdec(start, p)
+#else
+#define LAST_CHAR(buf,len) ((len) < 1 ? '\0' : *((buf) + (len) - 1))
+#define STRINC(p) p + 1
+#define STRDEC(start, p) p - 1
+#endif
+
 
 DEFUN ("buffer-live-p", Fbuffer_live_p, Sbuffer_live_p, 1, 1, 0,
        doc: /* Return non-nil if OBJECT is a buffer which has not been killed.
@@ -5345,7 +5358,10 @@
       /* Maybe this should really use some standard subroutine
          whose definition is filename syntax dependent.  */
       len = strlen (pwd);
+/* patch20101016
       if (!(IS_DIRECTORY_SEP (pwd[len - 1])))
+*/
+      if (!(IS_DIRECTORY_SEP (LAST_CHAR(pwd, len))))
         {
           /* Grow buffer to add directory separator and '\0'.  */
           pwd = realloc (pwd, len + 2);
diff -r -u emacs-26.3/src/config.in emacs-26.3/src/config.in
--- emacs-26.3/src/config.in	2019-08-22 07:43:50.000000000 +0900
+++ emacs-26.3/src/config.in	2020-04-22 21:40:51.310467000 +0900
@@ -1345,6 +1345,9 @@
 /* Define to use gmalloc before dumping and the system malloc after. */
 #undef HYBRID_MALLOC
 
+/* Define to use w32 ime unicode. */
+#undef IME_UNICODE
+
 /* This is substituted when $TERM is "internal". */
 #undef INTERNAL_TERMINAL
 
@@ -1702,6 +1705,9 @@
    safe for multithreaded apps. */
 #undef USE_UNLOCKED_IO
 
+/* Define to use w32 ime. */
+#undef USE_W32_IME
+
 /* Define to 1 if you have the XCB library and X11-XCB library for mixed
    X11/XCB programming. */
 #undef USE_XCB
diff -r -u emacs-26.3/src/doprnt.c emacs-26.3/src/doprnt.c
--- emacs-26.3/src/doprnt.c	2019-01-07 23:26:07.000000000 +0900
+++ emacs-26.3/src/doprnt.c	2019-08-29 22:10:56.440956400 +0900
@@ -161,9 +161,9 @@
   if (format_end == 0)
     format_end = format + strlen (format);
 
-  fmtcpy = (format_end - format < sizeof (fixed_buffer) - 1
+    fmtcpy = (format_end - format + 1 + 1 < sizeof (fixed_buffer)
 	    ? fixed_buffer
-	    : SAFE_ALLOCA (format_end - format + 1));
+	    : SAFE_ALLOCA (format_end - format + 1 + 1));
 
   bufsize--;
 
diff -r -u emacs-26.3/src/editfns.c emacs-26.3/src/editfns.c
--- emacs-26.3/src/editfns.c	2019-04-12 04:45:31.000000000 +0900
+++ emacs-26.3/src/editfns.c	2019-08-29 22:10:56.440956400 +0900
@@ -21,6 +21,7 @@
 #include <config.h>
 #include <sys/types.h>
 #include <stdio.h>
+#include <math.h>
 
 #ifdef HAVE_PWD_H
 #include <pwd.h>
@@ -1797,6 +1798,8 @@
 
    Return 1 if successful, 0 if the components are of the
    wrong type, and -1 if the time is out of range.  */
+__thread double t_tls ;
+
 int
 decode_time_components (Lisp_Object high, Lisp_Object low, Lisp_Object usec,
 			Lisp_Object psec,
@@ -1810,11 +1813,12 @@
     {
       if (FLOATP (low))
 	{
-	  double t = XFLOAT_DATA (low);
-	  if (result && ! decode_float_time (t, result))
+	  t_tls = XFLOAT_DATA (low);
+	  if( isnan(t_tls)!=0 ){t_tls=0.0;}
+	  if (result && ! decode_float_time (t_tls, result))
 	    return -1;
 	  if (dresult)
-	    *dresult = t;
+	    *dresult = t_tls;
 	  return 1;
 	}
       else if (NILP (low))
diff -r -u emacs-26.3/src/frame.c emacs-26.3/src/frame.c
--- emacs-26.3/src/frame.c	2019-06-12 19:50:42.000000000 +0900
+++ emacs-26.3/src/frame.c	2019-12-07 23:46:29.629656200 +0900
@@ -3571,6 +3571,9 @@
   {"fullscreen",                SYMBOL_INDEX (Qfullscreen)},
   {"font-backend",		SYMBOL_INDEX (Qfont_backend)},
   {"alpha",			SYMBOL_INDEX (Qalpha)},
+#ifdef USE_W32_IME
+  {"ime-font",			SYMBOL_INDEX (Qime_font)},
+#endif /* USE_W32_IME */
   {"sticky",			SYMBOL_INDEX (Qsticky)},
   {"tool-bar-position",		SYMBOL_INDEX (Qtool_bar_position)},
   {"inhibit-double-buffering",  SYMBOL_INDEX (Qinhibit_double_buffering)},
diff -r -u emacs-26.3/src/image.c emacs-26.3/src/image.c
--- emacs-26.3/src/image.c	2019-06-12 19:50:42.000000000 +0900
+++ emacs-26.3/src/image.c	2020-02-23 09:14:51.722774800 +0900
@@ -594,6 +594,102 @@
   return p;
 }
 
+Lisp_Object Qnever, Qwidth_or_height;
+
+static void image_error (const char *format, ...);
+static int get_fit_size(Lisp_Object opt, const struct frame *f,
+			int *w, int *h,
+			Lisp_Object image_type, int rise_error)
+{
+  if (NILP(opt))
+    return 0;
+
+  if (EQ(opt, Qnever)) {
+    *w = *h = 0;
+  } else if (EQ(opt, Qframe)) {
+    *w = FRAME_PIXEL_WIDTH (f) - FRAME_CONFIG_SCROLL_BAR_WIDTH (f) - FRAME_SCROLL_BAR_AREA_WIDTH (f);
+    *h = FRAME_PIXEL_HEIGHT (f);
+  } else if (EQ(opt, Qwidth_or_height)) {
+    *w = -(FRAME_PIXEL_WIDTH (f) - FRAME_CONFIG_SCROLL_BAR_WIDTH (f) - FRAME_SCROLL_BAR_AREA_WIDTH (f));
+    *h = -FRAME_PIXEL_HEIGHT (f);
+  } else if (EQ(opt, Qwidth)) {
+    *w = FRAME_PIXEL_WIDTH (f) - FRAME_CONFIG_SCROLL_BAR_WIDTH (f) - FRAME_SCROLL_BAR_AREA_WIDTH (f);
+    *h = 0;
+  } else if (EQ(opt, Qheight)) {
+    *w = 0;
+    *h = FRAME_PIXEL_HEIGHT (f);
+  } else {
+    if (rise_error)
+      xsignal2 (Qnil, build_string("unknown fit type"), opt);
+    else
+      image_error ("Invalid fit option for %s", image_type, Qnil);
+    return -1;
+  }
+  return 1;
+}
+
+static Lisp_Object image_spec_value (Lisp_Object, Lisp_Object, bool *);
+static int
+lookup_fit_size(Lisp_Object image_type,
+		const struct frame *f,
+		const struct image *img,
+		int *w, int *h,	int rise_error)
+{
+  Lisp_Object a, err, pred;
+  static const struct frame f_ = {0};
+  int w_, h_;
+  int r;
+
+//  assert(SYMBOLP (image_type));
+
+  if (img &&
+      (r = get_fit_size(image_spec_value(img->spec, QCfit, NULL),
+			f, w, h, image_type, rise_error)) != 0)
+    return r;
+
+#if 0
+  if (!CONSP (err = Vimage_fit_option_alist)) {
+    pred = Qconsp;
+    goto error;
+  }
+#endif
+
+  for (a = Vimage_fit_option_alist; !NILP(a); a = XCDR(a)) {
+    Lisp_Object o;
+    {
+      Lisp_Object e = XCAR(a);
+
+      if (!CONSP(err = e)) {
+	pred = Qconsp;
+	goto error;
+      }
+
+      if (!EQ(XCAR(e), image_type))
+	continue;
+      o = XCDR(e);
+    }
+
+    if (!SYMBOLP(err = o)) {
+      pred = Qsymbolp;
+      goto error;
+    }
+    if (f)
+      return get_fit_size(o, f, w, h, image_type, rise_error);
+    get_fit_size(o, &f_, &w_, &h_, image_type, rise_error);
+  }
+
+  /* not found */
+  if (f)
+    *w = *h = 0;
+  return 0;
+
+ error:
+  if (rise_error)
+    wrong_type_argument(pred, err);
+  else
+    image_error ("Invalid fit option for %s", image_type, Qnil);
+  return -1;
+}
 
 /* Value is true if OBJECT is a valid Lisp image specification.  A
    valid image specification is a list whose car is the symbol
@@ -6710,6 +6806,10 @@
   unsigned long *colors;
   XImagePtr ximg = NULL;
 #endif
+  int fit_width = 0, fit_height = 0;
+
+  if (lookup_fit_size (Qjpeg, f, img, &fit_width, &fit_height, !0) < 0)
+    return 0;
 
   /* Open the JPEG file.  */
   specified_file = image_spec_value (img->spec, QCfile, NULL);
@@ -6789,9 +6889,46 @@
 
   jpeg_read_header (&mgr->cinfo, 1);
 
+#define JPEG8C_UNIT 8
+
+  if (fit_width > 0 && fit_height == 0) {
+    if (mgr->cinfo.image_width > fit_width) { /* fit to width */
+      mgr->cinfo.scale_num = ((double) fit_width / mgr->cinfo.image_width) * JPEG8C_UNIT;
+      mgr->cinfo.scale_denom = JPEG8C_UNIT;
+    }
+  } else if (fit_width == 0 && fit_height > 0) {
+    if (mgr->cinfo.image_height > fit_height) { /* fit to width */
+      mgr->cinfo.scale_num = ((double)fit_height / mgr->cinfo.image_height) * JPEG8C_UNIT;
+      mgr->cinfo.scale_denom = JPEG8C_UNIT;
+    }
+  } else if (fit_width > 0 && fit_height > 0) { /* fit to frame */
+    if (mgr->cinfo.image_width > fit_width ||
+      mgr->cinfo.image_height > fit_height) {
+      if ((double)fit_width / mgr->cinfo.image_width <
+        (double)fit_height / mgr->cinfo.image_height) {
+      mgr->cinfo.scale_num = ((double)fit_width / mgr->cinfo.image_width) * JPEG8C_UNIT;
+      } else {
+      mgr->cinfo.scale_num = ((double)fit_height / mgr->cinfo.image_height) * JPEG8C_UNIT;
+      mgr->cinfo.scale_denom = JPEG8C_UNIT;
+      }
+    }
+  } else if (fit_width < 0 && fit_height < 0) { /* fit to width or height */
+    if (mgr->cinfo.image_width > -fit_width &&
+      mgr->cinfo.image_height > -fit_height) {
+      if ((double)-fit_width / mgr->cinfo.image_width >
+        (double)-fit_height / mgr->cinfo.image_height) {
+      mgr->cinfo.scale_num = ((double)-fit_width / mgr->cinfo.image_width) * JPEG8C_UNIT;
+      mgr->cinfo.scale_denom = JPEG8C_UNIT;
+      } else {
+      mgr->cinfo.scale_num = ((double)-fit_height / mgr->cinfo.image_height) * JPEG8C_UNIT;
+      mgr->cinfo.scale_denom = JPEG8C_UNIT;
+      }
+    }
+  }
+
   /* Customize decompression so that color quantization will be used.
 	 Start decompression.  */
-  mgr->cinfo.quantize_colors = 1;
+  //mgr->cinfo.quantize_colors = 1;
   jpeg_start_decompress (&mgr->cinfo);
   width = img->width = mgr->cinfo.output_width;
   height = img->height = mgr->cinfo.output_height;
@@ -6881,8 +7018,17 @@
   for (y = 0; y < height; ++y)
     {
       jpeg_read_scanlines (&mgr->cinfo, buffer, 1);
-      for (x = 0; x < mgr->cinfo.output_width; ++x)
-	XPutPixel (ximg, x, y, colors[buffer[0][x]]);
+      for (x = 0; x < mgr->cinfo.output_width; ++x){
+        if( mgr->cinfo.quantize_colors==1 ){
+          XPutPixel (ximg, x, y, colors[buffer[0][x]]);
+        }else{
+          if( mgr->cinfo.output_components==1 ){
+            XPutPixel (ximg, x, y, lookup_rgb_color (f, buffer[0][x]<<8, buffer[0][x]<<8, buffer[0][x]<<8));
+          }else{
+            XPutPixel (ximg, x, y, lookup_rgb_color (f, buffer[0][x*3]<<8, buffer[0][x*3+1]<<8, buffer[0][x*3+2]<<8));
+          }
+        }
+      }
     }
 #endif
 
@@ -8924,6 +9070,10 @@
 {
   bool success_p = 0;
   Lisp_Object file_name;
+  int w, h;
+
+  if (lookup_fit_size(Qjpeg, NULL, NULL, NULL, NULL, !0) < 0)
+    return 0;
 
   /* If IMG->spec specifies a file name, create a non-file spec from it.  */
   file_name = image_spec_value (img->spec, QCfile, NULL);
@@ -9255,6 +9405,7 @@
   else
     {
       Lisp_Object data, original_filename;
+      char *dummy_svg_filename=NULL ;
 
       data = image_spec_value (img->spec, QCdata, NULL);
       if (!STRINGP (data))
@@ -9262,9 +9413,14 @@
 	  image_error ("Invalid image data `%s'", data);
 	  return 0;
 	}
+      if( STRINGP(Vsvg_dummyfile_name_for_buffer_render) )
+	{
+	  dummy_svg_filename=SSDATA(Vsvg_dummyfile_name_for_buffer_render) ;
+	}
+
       original_filename = BVAR (current_buffer, filename);
       success_p = svg_load_image (f, img, SSDATA (data), SBYTES (data),
-                                  (NILP (original_filename) ? NULL
+                                  (NILP (original_filename) ? dummy_svg_filename
 				   : SSDATA (original_filename)));
     }
 
@@ -9923,6 +10079,7 @@
   DEFSYM (QCscale, ":scale");
   DEFSYM (QCcolor_adjustment, ":color-adjustment");
   DEFSYM (QCmask, ":mask");
+  DEFSYM (QCfit, ":fit");
 
   /* Other symbols.  */
   DEFSYM (Qlaplace, "laplace");
@@ -9973,12 +10130,23 @@
 	);
 #endif
 
+  DEFVAR_LISP ("image-fit-option-alist", Vimage_fit_option_alist,
+    doc: /* Alist of (IMAGE-TYPE . FIT-OPTION) pairs used by image loader to specify image size.
+the FIT-OPTION is one of 'never, 'frame, 'width-or-height, 'width or 'height.
+Note: All image loaders are not supporting this `fit' capability. */);
+  Vimage_fit_option_alist = Qnil;
+
   DEFSYM (Qpbm, "pbm");
   ADD_IMAGE_TYPE (Qpbm);
 
   DEFSYM (Qxbm, "xbm");
   ADD_IMAGE_TYPE (Qxbm);
 
+  Qnever = intern_c_string("never");
+  staticpro (&Qnever);
+  Qwidth_or_height = intern_c_string("width-or-height");
+  staticpro (&Qwidth_or_height);
+
 #if defined (HAVE_XPM) || defined (HAVE_NS)
   DEFSYM (Qxpm, "xpm");
   ADD_IMAGE_TYPE (Qxpm);
@@ -10012,7 +10180,7 @@
 #if defined (HAVE_RSVG)
   DEFSYM (Qsvg, "svg");
   ADD_IMAGE_TYPE (Qsvg);
-#ifdef HAVE_NTGUI
+#if defined HAVE_NTGUI && !defined CYGWIN
   /* Other libraries used directly by svg code.  */
   DEFSYM (Qgdk_pixbuf, "gdk-pixbuf");
   DEFSYM (Qglib, "glib");
@@ -10068,4 +10236,7 @@
   imagemagick_render_type = 0;
 #endif
 
+  DEFVAR_LISP ("svg-dummyfile-name-for-buffer-render", Vsvg_dummyfile_name_for_buffer_render,
+    doc: /* String of svg-dummy-file-name for buffer rendering.  */);
+
 }
diff -r -u emacs-26.3/src/keyboard.c emacs-26.3/src/keyboard.c
--- emacs-26.3/src/keyboard.c	2019-06-12 19:50:42.000000000 +0900
+++ emacs-26.3/src/keyboard.c	2019-08-29 22:10:56.471142800 +0900
@@ -4730,7 +4730,11 @@
     "junja",          /* VK_JUNJA          0x17 */
     "final",          /* VK_FINAL          0x18 */
     "kanji",          /* VK_KANJI/VK_HANJA 0x19 */
+#ifdef USE_W32_IME
+    "compend",        /* VK_COMPEND        0x1A */
+#else
     0,                /*    0x1A                */
+#endif /* USE_W32_IME */
     "escape",         /* VK_ESCAPE         0x1B */
     "convert",        /* VK_CONVERT        0x1C */
     "non-convert",    /* VK_NONCONVERT     0x1D */
@@ -8917,6 +8921,13 @@
 {
   ptrdiff_t count = SPECPDL_INDEX ();
 
+  /* To control IME */
+#ifdef USE_W32_IME
+  extern Lisp_Object Fime_force_on (), Fime_force_off (), Fime_get_mode ();
+  Lisp_Object VIME_command_off_flag = Qnil;
+  Lisp_Object IME_command_loop_flag = Qnil;
+#endif /* USE_W32_IME */
+
   /* How many keys there are in the current key sequence.  */
   int t;
 
@@ -9034,6 +9045,12 @@
      keybuf[0..mock_input] holds the sequence we should reread.  */
  replay_sequence:
 
+#ifdef USE_W32_IME
+/* If key sequences are to replay, IME_loop_flag should not be set.
+   Because event has never been occured. */
+  IME_command_loop_flag = Qnil;
+#endif /* USE_W32_IME */
+
   starting_buffer = current_buffer;
   first_unbound = bufsize + 1;
 
@@ -9113,6 +9130,16 @@
 	  goto replay_sequence;
 	}
 
+#ifdef USE_W32_IME
+      if (!NILP (IME_command_loop_flag) && NILP (VIME_command_off_flag))
+	{
+	  VIME_command_off_flag = Fime_get_mode ();
+	  if (!NILP (VIME_command_off_flag))
+	    Fime_force_off (Qnil);
+	}
+      IME_command_loop_flag = Qt;
+#endif /* USE_W32_IME */
+
       if (t >= bufsize)
 	error ("Key sequence too long");
 
@@ -9785,6 +9812,12 @@
     ? Fcommand_remapping (read_key_sequence_cmd, Qnil, Qnil)
     : Qnil;
 
+  /* to control IME */
+#ifdef USE_W32_IME
+  if (!NILP (VIME_command_off_flag))
+    Fime_force_on (Qnil);
+#endif /* USE_W32_IME */
+
   unread_switch_frame = delayed_switch_frame;
   unbind_to (count, Qnil);
 
diff -r -u emacs-26.3/src/process.c emacs-26.3/src/process.c
--- emacs-26.3/src/process.c	2019-07-28 05:15:09.000000000 +0900
+++ emacs-26.3/src/process.c	2019-08-29 22:10:56.471142800 +0900
@@ -21,6 +21,7 @@
 
 #include <config.h>
 
+#define FD_SETSIZE 1024
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
@@ -240,7 +241,7 @@
 # define HAVE_SEQPACKET
 #endif
 
-#define READ_OUTPUT_DELAY_INCREMENT (TIMESPEC_RESOLUTION / 100)
+#define READ_OUTPUT_DELAY_INCREMENT (TIMESPEC_RESOLUTION / 1000000)
 #define READ_OUTPUT_DELAY_MAX       (READ_OUTPUT_DELAY_INCREMENT * 5)
 #define READ_OUTPUT_DELAY_MAX_MAX   (READ_OUTPUT_DELAY_INCREMENT * 7)
 
@@ -5864,7 +5865,7 @@
   struct Lisp_Process *p = XPROCESS (proc);
   struct coding_system *coding = proc_decode_coding_system[channel];
   int carryover = p->decoding_carryover;
-  enum { readmax = 4096 };
+  enum { readmax = 4096*4 };
   ptrdiff_t count = SPECPDL_INDEX ();
   Lisp_Object odeactivate;
   char chars[sizeof coding->carryover + readmax];
@@ -5896,8 +5897,17 @@
 				    readmax - buffered);
       else
 #endif
-	nbytes = emacs_read (channel, chars + carryover + buffered,
-			     readmax - buffered);
+	{
+	  int i;
+	  int nnbytes ;
+	  nbytes=0 ;
+	  for( i=0 ; i<20 ; i++ ){
+	    nnbytes = emacs_read (channel, chars + carryover + buffered + nbytes, readmax - (buffered+nbytes));
+	    if( nnbytes<=0 ) break ;
+	    nbytes+=nnbytes ;
+	    if( (readmax - (buffered+nbytes))<=0 ) break ;
+	  }
+	}
       if (nbytes > 0 && p->adaptive_read_buffering)
 	{
 	  int delay = p->read_output_delay;
diff -r -u emacs-26.3/src/w32.c emacs-26.3/src/w32.c
--- emacs-26.3/src/w32.c	2019-01-07 23:26:07.000000000 +0900
+++ emacs-26.3/src/w32.c	2019-08-29 22:10:56.471142800 +0900
@@ -2070,7 +2070,7 @@
 		 Otherwise, the default group name was already set to
 		 "None" in globals_of_w32.  */
 	      if (lookup_account_sid (NULL, group_token.PrimaryGroup,
-				      gname, &glength, NULL, &dlength,
+				      gname, &glength, domain, &dlength,
 				      &user_type))
 		strcpy (dflt_group_name, gname);
 	    }
@@ -3029,6 +3029,18 @@
     }
 }
 
+/* patch20101016 */
+#ifdef WINDOWSNT
+#include <mbstring.h>
+#define LAST_CHAR(buf,len) ((len) < 1 ? '\0' : *_mbsdec((buf), (buf) + (len)))
+#define STRINC(p) _mbsinc(p)
+#define STRDEC(start, p) _mbsdec(start, p)
+#else
+#define LAST_CHAR(buf,len) ((len) < 1 ? '\0' : *((buf) + (len) - 1))
+#define STRINC(p) p + 1
+#define STRDEC(start, p) p - 1
+#endif
+
 
 /* ------------------------------------------------------------------------- */
 /* IO support and wrapper functions for the Windows API. */
@@ -7088,7 +7100,7 @@
 		      dlength = sizeof (domain);
 		      result =
 			lookup_account_sid (NULL, group_token.PrimaryGroup,
-					    gname, &glength, NULL, &dlength,
+					    gname, &glength, domain, &dlength,
 					    &user_type);
 		      if (result)
 			w32_add_to_cache (group_token.PrimaryGroup,
diff -r -u emacs-26.3/src/w32fns.c emacs-26.3/src/w32fns.c
--- emacs-26.3/src/w32fns.c	2019-01-07 23:26:07.000000000 +0900
+++ emacs-26.3/src/w32fns.c	2020-04-27 01:54:26.974642200 +0900
@@ -56,6 +56,11 @@
 #include "w32.h"
 #endif
 
+#ifdef USE_W32_IME
+#include "fontset.h"
+#include "w32font.h"
+#endif
+
 #include <basetyps.h>
 #include <unknwn.h>
 #include <commctrl.h>
@@ -83,6 +88,45 @@
 #define IDC_HAND MAKEINTRESOURCE(32649)
 #endif
 
+#ifdef USE_W32_IME
+#ifdef RECONVERSION
+#define CHRSZ sizeof(short)
+#define RECONV_LENG 100
+#define DOCFEED_LENG 100
+static LRESULT w32_get_ime_reconversion_string (HWND, RECONVERTSTRING*);
+static BOOL w32_perform_reconversion (HWND, RECONVERTSTRING*);
+#ifdef DOCUMENTFEED
+#define DOCFEED_CSTR_LENG 64
+static LRESULT w32_get_ime_documentfeed_string (HWND, RECONVERTSTRING*);
+#endif
+#endif
+static int set_ime_font = 0;
+static LOGFONT ime_logfont = {0};
+static int IME_event_off_count;
+Lisp_Object Fime_get_mode();
+const char * const ImmGetOpenStatus_Name = "ImmGetOpenStatus";
+const char * const ImmSetOpenStatus_Name = "ImmSetOpenStatus";
+const char * const ImmSetCompositionWindow_Name = "ImmSetCompositionWindow";
+const char * const ImmGetContext_Name = "ImmGetContext";
+const char * const ImmGetConversionStatus_Name = "ImmGetConversionStatus";
+const char * const ImmSetConversionStatus_Name = "ImmSetConversionStatus";
+const char * const ImmNotifyIME_Name = "ImmNotifyIME";
+
+const char * const ImmReleaseContext_Name = "ImmReleaseContext";
+const char * const ImmCreateContext_Name = "ImmCreateContext";
+const char * const ImmDestroyContext_Name = "ImmDestroyContext";
+const char * const ImmAssociateContext_Name = "ImmAssociateContext";
+const char * const ImmGetHotKey_Name = "ImmGetHotKey";
+const char * const ImmGetProperty_Name = "ImmGetProperty";
+const char * const ImmGetCompositionString_Name = "ImmGetCompositionStringW";
+const char * const ImmSetCompositionString_Name = "ImmSetCompositionStringW";
+const char * const ImmSetCompositionFont_Name = "ImmSetCompositionFontA"; /* LOGFONTA */
+const char * const ImmGetConversionList_Name = "ImmGetConversionListW";
+const char * const ImmConfigureIME_Name = "ImmConfigureIMEW";
+const char * const ImmGetCandidateList_Name = "ImmGetCandidateListW";
+const char * const ImmGetCandidateListCount_Name = "ImmGetCandidateListCountW";
+#endif
+
 /* Prefix for system colors.  */
 #define SYSTEM_COLOR_PREFIX "System"
 #define SYSTEM_COLOR_PREFIX_LEN (sizeof (SYSTEM_COLOR_PREFIX) - 1)
@@ -176,10 +220,14 @@
   (IN HWND hwnd, OUT TITLEBAR_INFO* info);
 
 TrackMouseEvent_Proc track_mouse_event_fn = NULL;
+
+#ifndef USE_W32_IME
 ImmGetCompositionString_Proc get_composition_string_fn = NULL;
 ImmGetContext_Proc get_ime_context_fn = NULL;
 ImmReleaseContext_Proc release_ime_context_fn = NULL;
 ImmSetCompositionWindow_Proc set_ime_composition_window_fn = NULL;
+#endif
+
 MonitorFromPoint_Proc monitor_from_point_fn = NULL;
 GetMonitorInfo_Proc get_monitor_info_fn = NULL;
 MonitorFromWindow_Proc monitor_from_window_fn = NULL;
@@ -188,8 +236,14 @@
 
 extern AppendMenuW_Proc unicode_append_menu;
 
+#ifdef USE_W32_IME
+/* Flag for indicating in conversion.  */
+int ime_in_conversion = 0;
+int flag_called_get_ime_status = 0 ;
+#else
 /* Flag to selectively ignore WM_IME_CHAR messages.  */
 static int ignore_ime_char = 0;
+#endif
 
 /* W95 mousewheel handler */
 unsigned int msh_mousewheel = 0;
@@ -362,6 +416,18 @@
 void x_set_icon_name (struct frame *, Lisp_Object, Lisp_Object);
 void x_explicitly_set_name (struct frame *, Lisp_Object, Lisp_Object);
 void x_set_title (struct frame *, Lisp_Object, Lisp_Object);
+#ifdef USE_W32_IME
+void w32_set_ime_conv_window (HWND, struct frame *);
+void w32_set_ime_status (HWND, int);
+int w32_get_ime_status (HWND);
+int w32_set_ime_mode (HWND, int, int);
+void w32_ime_control_init (void);
+static void w32_set_ime_font (HWND);
+void w32_set_ime_logfont (HWND, struct frame *);
+BOOL w32_get_ime_composition_string (HWND);
+LRESULT CALLBACK conversion_agent_wndproc (HWND, UINT, WPARAM, LPARAM);
+int initialize_conversion_agent ();
+#endif /* USE_W32_IME */
 
 
 /* Store the screen positions of frame F into XPTR and YPTR.
@@ -3612,6 +3678,23 @@
 	  doubled = code_unit;
 	  continue;
 	}
+      else
+	{
+	  extern int w32_get_ime_status (HWND);
+	  MSG ime_undo_test_msg;
+
+	  if (msg.wParam == VK_BACK
+	      && ctrl_modifier == w32_get_key_modifiers (msg.wParam, msg.lParam)
+	      && w32_get_ime_status (msg.hwnd) != 0
+	      && PeekMessage (&ime_undo_test_msg, msg.hwnd, WM_KEYDOWN, WM_KEYDOWN, PM_NOYIELD | PM_NOREMOVE) != 0
+	      && ime_undo_test_msg.wParam == VK_BACK
+	      && ime_undo_test_msg.lParam == 0x40000001
+	      )
+	    {
+	      post_character_message (msg.hwnd, msg.message, msg.wParam, msg.lParam, 0);
+	      break;
+	    }
+	}
 
       /* The only "fake" characters delivered by ToUnicode() or
 	 TranslateMessage() are:
@@ -4437,6 +4520,7 @@
 				w32_get_key_modifiers (wParam, lParam));
       break;
 
+#ifndef USE_W32_IME
     case WM_UNICHAR:
       /* WM_UNICHAR looks promising from the docs, but the exact
 	 circumstances in which TranslateMessage sends it is one of those
@@ -4561,6 +4645,7 @@
     case WM_IME_ENDCOMPOSITION:
       ignore_ime_char = 0;
       goto dflt;
+#endif /* USE_W32_IME */
 
       /* Simulate middle mouse button events when left and right buttons
 	 are used together, but only if user has two button mouse. */
@@ -5380,7 +5465,80 @@
       my_post_msg (&wmsg, hwnd, msg, wParam, lParam);
       return 1;
 
+#ifdef USE_W32_IME
+    case WM_IME_NOTIFY:
+      if (wParam == IMN_SETOPENSTATUS || wParam == 269/*???*/)
+	{
+	  if (w32_get_ime_status(hwnd))
+	    {
+	      struct frame *f = x_window_to_frame (dpyinfo, hwnd);
+	      if (f)
+	        my_post_msg (&wmsg, hwnd, WM_MULE_IME_SET_FONT, (WPARAM) f, 0);
+	    }
+	}
+
+      if (wParam == IMN_SETOPENSTATUS)
+	{
+	  if (!IME_event_off_count)
+	    my_post_msg (&wmsg, hwnd, WM_MULE_IME_STATUS, 0, 0);
+	  else
+	    IME_event_off_count--;
+	}
+      goto dflt;
+
+    case WM_IME_STARTCOMPOSITION:
+      {
+	struct frame *f = x_window_to_frame (dpyinfo, hwnd);
+	if (f && !set_ime_font)
+	  {
+	    my_post_msg (&wmsg, hwnd, WM_MULE_IME_SET_FONT, (WPARAM) f, 0);
+	    set_ime_font = 1;
+	  }
+      }
+      ime_in_conversion = 1;
+      goto dflt;
+
+    case WM_IME_COMPOSITION:
+      {
+	if (lParam & GCS_RESULTSTR)
+	  {
+	    if (w32_get_ime_composition_string (hwnd))
+	      return 0;
+	    else
+	      break;
+	}
+	goto dflt;
+      }
+
+  case WM_MULE_IMM_SET_CONVERSION_WINDOW:
+    w32_set_ime_conv_window (hwnd, (struct frame *) wParam);
+    break;
+
+  case WM_MULE_IMM_SET_IMEFONT:
+    w32_set_ime_font(hwnd);
+    break;
+
+#ifdef RECONVERSION
+    case WM_IME_REQUEST:
+      if (wParam == IMR_RECONVERTSTRING)
+	if (lParam)
+	  return w32_get_ime_reconversion_string (hwnd, wParam,
+						  (RECONVERTSTRING*) lParam);
+	else
+	  return w32_get_ime_reconversion_length ();
+      goto dflt;
+#endif /* RECONVERSION */
+#endif /* USE_W32_IME */
+
     default:
+
+#ifdef USE_W32_IME
+      {
+	if (MESSAGE_IMM_COM_P(msg))
+	  return conversion_agent_wndproc (hwnd, msg, wParam, lParam);
+      }
+#endif /* USE_W32_IME */
+
       /* Check for messages registered at runtime. */
       if (msg == msh_mousewheel)
 	{
@@ -5671,6 +5829,10 @@
 					Qnil));
     }
   x_default_parameter (f, parms, Qfont, font, "font", "Font", RES_TYPE_STRING);
+#ifdef USE_W32_IME
+  x_default_parameter (f, parms, Qime_font, Qnil,
+		       "ime-font", "IME-Font", RES_TYPE_STRING);
+#endif
 }
 
 DEFUN ("x-create-frame", Fx_create_frame, Sx_create_frame,
@@ -8170,6 +8332,981 @@
 #endif /* WINDOWSNT */
 
 
+  /***********************************************************************
+ 			  Input Method Editor
+ ***********************************************************************/
+#ifdef USE_W32_IME
+#define MAX_CONVAGENT 100
+
+typedef struct conversion_agent {
+  HIMC himc;
+  HWND hwnd;
+} conversion_agent;
+
+static conversion_agent agent[MAX_CONVAGENT];
+static int conversion_agent_num = -1;
+
+BOOL fIME = FALSE;
+
+typedef BOOL (WINAPI *IMMGETOPENSTATUSPROC)(HIMC);
+IMMGETOPENSTATUSPROC ImmGetOpenStatusProc;
+
+typedef BOOL (WINAPI *IMMSETOPENSTATUSPROC)(HIMC, BOOL);
+IMMSETOPENSTATUSPROC ImmSetOpenStatusProc;
+
+typedef BOOL (WINAPI *IMMSETCOMPOSITIONWINDOWPROC)(HIMC, LPCOMPOSITIONFORM);
+IMMSETCOMPOSITIONWINDOWPROC ImmSetCompositionWindowProc;
+
+typedef LONG (WINAPI *IMMGETCOMPOSITIONSTRINGPROC)
+  (HIMC, DWORD, LPVOID, DWORD);
+IMMGETCOMPOSITIONSTRINGPROC ImmGetCompositionStringProc;
+
+typedef LONG (WINAPI *IMMSETCOMPOSITIONSTRINGPROC)
+  (HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
+IMMSETCOMPOSITIONSTRINGPROC ImmSetCompositionStringProc;
+
+typedef BOOL (WINAPI *IMMSETCOMPOSITIONFONTPROC) (HIMC, LPLOGFONTA);
+IMMSETCOMPOSITIONFONTPROC ImmSetCompositionFontProc;
+
+typedef HIMC (WINAPI *IMMGETCONTEXTPROC)(HWND);
+IMMGETCONTEXTPROC ImmGetContextProc;
+
+typedef BOOL (WINAPI *IMMGETCONVERSIONSTATUSPROC)(HIMC, LPDWORD, LPDWORD);
+IMMGETCONVERSIONSTATUSPROC ImmGetConversionStatusProc;
+
+typedef BOOL (WINAPI *IMMSETCONVERSIONSTATUSPROC)(HIMC, DWORD, DWORD);
+IMMSETCONVERSIONSTATUSPROC ImmSetConversionStatusProc;
+
+typedef BOOL (WINAPI *IMMGETCONVERSIONLISTPROC)
+  (HKL, HIMC, LPCTSTR, LPCANDIDATELIST, DWORD, UINT);
+IMMGETCONVERSIONLISTPROC ImmGetConversionListProc;
+
+typedef BOOL (WINAPI *IMMCONFIGUREIMEPROC)(HKL, HWND, DWORD, LPVOID);
+IMMCONFIGUREIMEPROC ImmConfigureIMEProc;
+
+typedef BOOL (WINAPI *IMMNOTIFYIMEPROC)(HIMC, DWORD, DWORD, DWORD);
+IMMNOTIFYIMEPROC ImmNotifyIMEProc;
+
+typedef BOOL (WINAPI *IMMRELEASECONTEXTPROC)(HWND, HIMC);
+IMMRELEASECONTEXTPROC ImmReleaseContextProc;
+
+typedef HIMC (WINAPI *IMMCREATECONTEXTPROC)(void);
+IMMCREATECONTEXTPROC ImmCreateContextProc;
+
+typedef BOOL (WINAPI *IMMDESTROYCONTEXTPROC)(HIMC);
+IMMDESTROYCONTEXTPROC ImmDestroyContextProc;
+
+typedef BOOL (WINAPI *IMMASSOCIATECONTEXTPROC) (HWND, HIMC);
+IMMASSOCIATECONTEXTPROC ImmAssociateContextProc;
+
+typedef BOOL (WINAPI *IMMGETCANDIDATELISTPROC)
+  (HIMC, DWORD, LPCANDIDATELIST, DWORD);
+IMMGETCANDIDATELISTPROC ImmGetCandidateListProc;
+
+typedef BOOL (WINAPI *IMMGETCANDIDATELISTCOUNTPROC) (HIMC, LPDWORD);
+IMMGETCANDIDATELISTCOUNTPROC ImmGetCandidateListCountProc;
+
+typedef BOOL (WINAPI *IMMGETHOTKEYPROC)(DWORD, LPUINT, LPUINT, LPHKL);
+IMMGETHOTKEYPROC ImmGetHotKeyProc;
+
+//Lisp_Object Vime_control;
+
+/*static*/ void
+w32_set_ime_conv_window (hwnd, f)
+     HWND hwnd;
+     struct frame *f;
+{
+  if (fIME && !NILP (Vime_control))
+    {
+      HIMC himc;
+      COMPOSITIONFORM compform;
+      struct window *w = XWINDOW (FRAME_SELECTED_WINDOW (f));
+
+      /* If Vw32_ime_composition_window is set, try it. */
+      if (!NILP (Vw32_ime_composition_window)
+	  && WINDOWP (Vw32_ime_composition_window)
+	  && WINDOW_FRAME (XWINDOW (Vw32_ime_composition_window))
+	  == WINDOW_FRAME (w))
+	w = XWINDOW (Vw32_ime_composition_window);
+
+      himc = (ImmGetContextProc) (hwnd);
+      compform.dwStyle = CFS_RECT;
+
+      compform.ptCurrentPos.x =	WINDOW_TEXT_TO_FRAME_PIXEL_X (w, w->phys_cursor.x);
+
+      compform.ptCurrentPos.y = WINDOW_TO_FRAME_PIXEL_Y (w, w->phys_cursor.y);
+#if 0
+      if (FRAME_FONT (f)->vertical_centering == 1)
+	compform.ptCurrentPos.y += FRAME_FONT (f)->baseline_offset;
+#endif
+      compform.rcArea.left = (WINDOW_BOX_LEFT_EDGE_X (w)
+			      + WINDOW_LEFT_MARGIN_WIDTH (w)
+			      + WINDOW_LEFT_FRINGE_WIDTH (w));
+
+      compform.rcArea.top = (WINDOW_TOP_EDGE_Y (w)
+			     + WINDOW_HEADER_LINE_HEIGHT (w));
+
+      compform.rcArea.right = (WINDOW_BOX_RIGHT_EDGE_X (w)
+			       - WINDOW_RIGHT_MARGIN_WIDTH (w)
+			       - WINDOW_RIGHT_FRINGE_WIDTH (w));
+
+      compform.rcArea.bottom = (WINDOW_BOTTOM_EDGE_Y (w)
+				- WINDOW_MODE_LINE_HEIGHT (w));
+
+      (ImmSetCompositionWindowProc) (himc, &compform);
+      (ImmReleaseContextProc) (hwnd, himc);
+    }
+}
+
+/*static*/ void
+w32_set_ime_status (hwnd, openp)
+     HWND hwnd;
+     int openp;
+{
+  HIMC himc;
+
+  himc = (ImmGetContextProc) (hwnd);
+  (ImmSetOpenStatusProc) (himc, openp);
+  (ImmReleaseContextProc) (hwnd, himc);
+}
+
+/*static*/ int
+w32_get_ime_status (hwnd)
+     HWND hwnd;
+{
+  HIMC himc;
+  int ret;
+
+  if( flag_called_get_ime_status==0 ){
+    SetFocus(NULL);
+    SetFocus(hwnd);
+    flag_called_get_ime_status=1 ;
+  }
+
+  himc = (ImmGetContextProc) (hwnd);
+  ret = (ImmGetOpenStatusProc) (himc);
+  (ImmReleaseContextProc) (hwnd, himc);
+
+  return ret;
+}
+
+/*static*/ int
+w32_set_ime_mode (hwnd, mode, mask)
+     HWND hwnd;
+     int mode;
+     int mask;
+{
+  HIMC himc;
+  DWORD cmode, smode;
+
+  himc = (ImmGetContextProc) (hwnd);
+  if (!(ImmGetConversionStatusProc) (himc, &cmode, &smode))
+    return 0;
+
+  cmode = (cmode & (~mask)) | (mode & mask);
+
+  (ImmSetConversionStatusProc) (himc, cmode, smode);
+  (ImmReleaseContextProc) (hwnd, himc);
+
+  return 1;
+}
+
+/*static*/ BOOL
+w32_get_ime_composition_string (hwnd)
+     HWND hwnd;
+{
+  HIMC hIMC;
+  int size;
+  HANDLE himestr;
+#ifdef IME_UNICODE
+  LPWSTR lpstr;
+#else
+  LPSTR lpstr;
+#endif
+
+  struct frame *f;
+
+  hIMC = (ImmGetContextProc) (hwnd);
+  if (!hIMC)
+    return FALSE;
+
+  size = (ImmGetCompositionStringProc) (hIMC, GCS_RESULTSTR, NULL, 0);
+#ifdef IME_UNICODE
+  size += sizeof (WCHAR);
+#else
+  size += sizeof (CHAR);
+#endif
+  himestr = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, size);
+  if (!himestr)
+    abort ();
+
+  (ImmGetCompositionStringProc) (hIMC, GCS_RESULTSTR, himestr, size);
+  (ImmReleaseContextProc) (hwnd, hIMC);
+  {
+    W32Msg wmsg;
+    f = SELECTED_FRAME ();
+    my_post_msg (&wmsg, hwnd, WM_MULE_IME_REPORT,
+		 (WPARAM) himestr, (LPARAM) f);
+  }
+  return TRUE;
+}
+
+EXFUN (Ffont_at, 3);
+
+#ifdef HAVE_NTGUI
+static int
+need_set_ime_font (PLOGFONT p)
+{
+  if (!p ||
+      (p->lfHeight            == ime_logfont.lfHeight
+       && p->lfWidth          == ime_logfont.lfWidth
+       && p->lfEscapement     == ime_logfont.lfEscapement
+       && p->lfOrientation    == ime_logfont.lfOrientation
+       && p->lfWeight         == ime_logfont.lfWeight
+       && p->lfItalic         == ime_logfont.lfItalic
+       && p->lfUnderline      == ime_logfont.lfUnderline
+       && p->lfStrikeOut      == ime_logfont.lfStrikeOut
+       && p->lfCharSet        == ime_logfont.lfCharSet
+       && p->lfOutPrecision   == ime_logfont.lfOutPrecision
+       && p->lfClipPrecision  == ime_logfont.lfClipPrecision
+       && p->lfQuality        == ime_logfont.lfQuality
+       && p->lfPitchAndFamily == ime_logfont.lfPitchAndFamily
+       && strncmp (p->lfFaceName, ime_logfont.lfFaceName, LF_FACESIZE) == 0))
+    return 0;
+  else
+    return 1;
+}
+void
+w32_set_ime_logfont (hwnd, f)
+     HWND hwnd;
+     struct frame *f;
+{
+  Lisp_Object ime_font = Qnil, temp = Qnil, font = Qnil, family;
+  int fsid = -1;
+  LOGFONT logfont = {0};
+
+  if (!IsWindow (hwnd))
+    return;
+
+  if (!fIME || NILP(Vime_control))
+    return;
+
+  if (FACE_FROM_ID(f,0)==NULL)
+    return;
+
+  if (STRINGP(ime_font = get_frame_param (f, Qime_font))
+          /* fontset */
+      && ((fsid = fs_query_fontset(ime_font, 0)) >= 0
+          && !NILP(font = fontset_ascii(fsid))
+          && !NILP(font = font_spec_from_name(font))
+          && !NILP(temp = Ffontset_font(temp, make_number(0x3042), Qnil))
+          && !NILP(family = XCAR(temp))
+          /* font */
+          || !NILP(font = font_spec_from_name(ime_font))
+          && SYMBOLP(family = AREF (font, FONT_FAMILY_INDEX))
+          && STRINGP(family = SYMBOL_NAME(family)))
+
+      /* use font object */
+          /* frame-parameter */
+      || (FONTP(font = ime_font)
+          /* frame fontset */
+          || ((fsid = FRAME_FONTSET(f)) >= 0
+              && !NILP(font =
+                   Ffont_at(make_number(0), Qnil,
+                            temp = Fchar_to_string(make_number(0x3042))))))
+      && SYMBOLP(family = Ffont_get(font, QCfamily))
+      && STRINGP(family = SYMBOL_NAME(family))
+      && !NILP(font = copy_font_spec(font))) {
+    Lisp_Object tail;
+
+    fill_in_logfont (f, &logfont, font);
+
+    logfont.lfWidth = 0;
+
+    family = ENCODE_SYSTEM(family);
+
+    strcpy(logfont.lfFaceName, SDATA(family));
+
+    /* rescale */
+    for (tail = Vface_font_rescale_alist; CONSP (tail); tail = XCDR (tail)) {
+      temp = XCAR (tail);
+      if (!FLOATP (XCDR (temp)))
+	continue;
+
+      if (STRINGP (XCAR (temp))) {
+	if (fast_string_match_ignore_case (XCAR (temp), family) >= 0) {
+	  logfont.lfHeight *=  XFLOAT_DATA (XCDR (temp));
+	  break;
+	}
+      } else if (FONT_SPEC_P (XCAR (temp))) {
+	Lisp_Object name;
+	if (!NILP(name = Ffont_get(XCAR (temp), QCfamily)) &&
+	    STRINGP(name) &&
+	    xstrcasecmp(SDATA(name), SDATA(family)) == 0) {
+	  logfont.lfHeight *=  XFLOAT_DATA (XCDR (temp));
+	  break;
+	}
+      }
+    }
+  } else {
+    HFONT hfont = FONT_HANDLE (FRAME_FONT (f));
+    GetObject (hfont, sizeof (logfont), &logfont);
+  }
+
+  if (need_set_ime_font (&logfont))
+    {
+      ime_logfont = logfont;
+      PostMessage (hwnd, WM_MULE_IMM_SET_IMEFONT, (WPARAM) f, 0);
+    }
+
+}
+static void
+w32_set_ime_font (hwnd)
+     HWND hwnd;
+{
+  HIMC himc;
+
+  if (!fIME || NILP (Vime_control))
+    return;
+
+  himc = (ImmGetContextProc) (hwnd);
+  if (!himc)
+    return;
+  (ImmSetCompositionFontProc) (himc, &ime_logfont);
+  (ImmReleaseContextProc) (hwnd, himc);
+}
+#endif  /* HAVE_NTGUI */
+
+#ifdef RECONVERSION
+LRESULT
+w32_get_ime_reconversion_length ()
+{
+  int len, pt, pt_byte, start, end;
+  Lisp_Object str, point;
+  LRESULT lResult = 0;
+#ifdef IME_UNICODE
+  int pos;
+  WCHAR *uc_code, *s;
+#else
+  struct coding_system coding;
+#endif
+
+  pt = PT;
+  pt_byte = PT_BYTE;
+
+  if (!NILP (BVAR (current_buffer, read_only)))
+    return 0;
+
+  if (!NILP (BVAR (current_buffer, mark_active))
+      && !NILP (Vtransient_mark_mode))
+    {
+      if (marker_position (BVAR (current_buffer, mark)) < PT)
+	{
+	  start = marker_position (BVAR (current_buffer, mark));
+	  point = Fpoint ();
+	  end = PT;
+	}
+      else
+	{
+	  start = PT;
+	  point = Fpoint ();
+	  end = marker_position (BVAR (current_buffer, mark));
+	}
+    }
+  else
+    {
+      if (NILP (Feobp ()))
+	Fforward_char (make_number (1));
+      Fforward_word (make_number (-1));
+      start = PT;
+      point = Fpoint ();
+      Fforward_word (make_number (1));
+      end = PT;
+    }
+  str = make_buffer_string (start, end, 1);
+  if (!NILP (Ftext_property_any (make_number (0),
+				 Flength (str),
+				 intern ("read-only"),
+				 Qt,
+				 str)))
+    {
+      SET_PT_BOTH (pt, pt_byte);
+      return FALSE;  /* Cannot signal here */
+    }
+#ifdef IME_UNICODE
+  /*
+  uc_code = (WCHAR *) alloca ((SCHARS (str) + 1) * sizeof (WCHAR));
+  s = uc_code;
+  for (pos = start; pos < end; pos++)
+    *s++ = (WCHAR) FETCH_CHAR (CHAR_TO_BYTE (pos));
+  *s = (WCHAR) '\0';
+  len = (lstrlenW (uc_code) + 1) * sizeof (WCHAR);
+   */
+  len = (end - start + 1) * sizeof (int);
+#else
+  str = Fdecode_coding_region (make_number (start), make_number (end), Vlocale_coding_system, Qt);
+  setup_coding_system (Fcheck_coding_system (Vlocale_coding_system),
+		     &coding);
+  coding.mode |= (CODING_MODE_SAFE_ENCODING | CODING_MODE_LAST_BLOCK);
+  coding.common_flags &= ~CODING_ANNOTATION_MASK;
+
+  coding.dst_bytes = SCHARS (str) * 2;
+  coding.destination = (unsigned char *) xmalloc (coding.dst_bytes + 2);
+  encode_coding_object (&coding, str, 0, 0, SCHARS (str), SBYTES (str), Qnil);
+
+  len = coding.produced + 1;
+  xfree (coding.destination);
+#endif
+  SET_PT_BOTH (pt, pt_byte);
+
+  /* Return need size on reconverted string */
+  lResult = sizeof (RECONVERTSTRING) + len;
+  return lResult;
+}
+
+BOOL
+w32_get_ime_reconversion_string (hwnd, wParam, reconv)
+     HWND hwnd;
+     WPARAM wParam;
+     RECONVERTSTRING *reconv;
+{
+  HIMC hIMC;
+  int len, result, start, end;
+  Lisp_Object str, point;
+  struct w32_display_info *dpyinfo = &one_w32_display_info;
+  struct frame *f = x_window_to_frame (dpyinfo, hwnd);
+  W32Msg wmsg;
+#ifdef IME_UNICODE
+  int pos;
+  WCHAR *uc_code, *s;
+#else
+  struct coding_system coding;
+#endif
+
+  if (!NILP (BVAR (current_buffer, mark_active))
+      && !NILP (Vtransient_mark_mode))
+    {
+      if (marker_position (BVAR (current_buffer, mark)) < PT)
+	{
+	  start = marker_position (BVAR (current_buffer, mark));
+	  point = Fpoint ();
+	  end = PT;
+	}
+      else
+	{
+	  start = PT;
+	  point = Fpoint ();
+	  end = marker_position (BVAR (current_buffer, mark));
+	}
+    }
+  else
+    {
+      if (NILP (Feobp ()))
+	Fforward_char (make_number (1));
+      Fforward_word (make_number (-1));
+      start = PT;
+      point = Fpoint ();
+      Fforward_word (make_number (1));
+      end = PT;
+    }
+
+#ifdef IME_UNICODE
+  /* str = make_buffer_string (start, end, 0); */
+  /* uc_code = (WCHAR *) alloca ((SCHARS (str) + 1) * sizeof (WCHAR)); */
+  uc_code = (WCHAR *) (reconv + 1);
+  s = uc_code;
+  for (pos = start; pos < end; pos++)
+    *s++ = (WCHAR) FETCH_CHAR (CHAR_TO_BYTE (pos));
+  *s = (WCHAR) '\0';
+  /* len = lstrlenW (uc_code); */
+  len = s - uc_code;
+  Fgoto_char (point);
+
+  hIMC = (ImmGetContextProc) (hwnd);
+  if (!hIMC)
+    {
+      return FALSE;
+    }
+
+  /* memcpy ((LPSTR) reconv + sizeof (RECONVERTSTRING),
+	  uc_code, len * sizeof (WCHAR)); */
+#else
+  str = Fdecode_coding_region (make_number (start), make_number (end), Vlocale_coding_system, Qt);
+  setup_coding_system (Fcheck_coding_system (Vlocale_coding_system),
+		     &coding);
+  coding.mode |= (CODING_MODE_SAFE_ENCODING | CODING_MODE_LAST_BLOCK);
+  coding.common_flags &= ~CODING_ANNOTATION_MASK;
+
+  coding.dst_bytes = SCHARS (str) * 2;
+  coding.destination = (unsigned char *) xmalloc (coding.dst_bytes + 2);
+  encode_coding_object (&coding, str, 0, 0, SCHARS (str), SBYTES (str), Qnil);
+  coding.destination[coding.produced] = '\0';
+  len = coding.produced;
+  Fgoto_char (point);
+
+  hIMC = (ImmGetContextProc) (hwnd);
+  if (!hIMC)
+    {
+      xfree (coding.destination);
+      return FALSE;
+    }
+  strcpy ((LPSTR) reconv + sizeof (RECONVERTSTRING), coding.destination);
+  xfree (coding.destination);
+#endif
+  reconv->dwStrLen = len;
+  reconv->dwStrOffset = sizeof (RECONVERTSTRING);
+  reconv->dwCompStrLen = len;
+  reconv->dwCompStrOffset = 0;
+
+  /* Reconverted area is all of selected strings. */
+  reconv->dwTargetStrLen = len;
+  reconv->dwTargetStrOffset = 0;
+
+#if 0
+  /* Automatically adjust RECONVERTSTRING if not selected. */
+  if (NILP (BVAR (current_buffer, mark_active))
+    (ImmSetCompositionStringProc) (hIMC,
+				   SCS_QUERYRECONVERTSTRING,
+				   (LPCVOID) reconv,
+				   reconv->dwSize,
+				   NULL, 0 );
+#endif
+  result = FALSE;
+  if ((ImmSetCompositionStringProc) (hIMC,
+  				     SCS_QUERYRECONVERTSTRING,
+  				     (LPCVOID) reconv,
+  				     reconv->dwSize,
+  				     NULL, 0 ))
+    {
+  if ((ImmSetCompositionStringProc) (hIMC,
+				     SCS_SETRECONVERTSTRING,
+				     (LPCVOID) reconv,
+				     reconv->dwSize,
+				     NULL, 0))
+    {
+      /* Delete the selected area. */
+	/* del_range (start, end); */
+	int *lparam = xmalloc (sizeof *lparam * 2);
+	lparam[0] = start;
+	lparam[1] = end;
+	my_post_msg (&wmsg, hwnd, WM_MULE_IME_DEL_RANGE, 0, (LPARAM) lparam);
+      /* Set the position of candidate list dialog. */
+	(ImmReleaseContextProc) (hwnd, hIMC);
+      w32_set_ime_conv_window (hwnd, f);
+      result = TRUE;
+    }
+    }
+  if (!result)
+  (ImmReleaseContextProc) (hwnd, hIMC);
+  result = 0;
+
+  return result;
+}
+#endif /* RECONVERSION */
+
+void
+w32_ime_control_init (void)
+{
+  HMODULE hImm32;
+  HMODULE hUser32;
+
+  hImm32 = GetModuleHandle ("IMM32.DLL");
+  if (!hImm32)
+    hImm32 = LoadLibrary ("IMM32.DLL");
+
+  fIME = FALSE;
+  Vime_control = Qnil;
+  IME_event_off_count = 0;
+
+  flag_called_get_ime_status=0 ;
+
+  if (hImm32)
+    {
+      ImmGetOpenStatusProc =
+	(IMMGETOPENSTATUSPROC)
+	GetProcAddress (hImm32,
+			ImmGetOpenStatus_Name);
+      ImmSetOpenStatusProc =
+	(IMMSETOPENSTATUSPROC)
+	GetProcAddress (hImm32,
+			ImmSetOpenStatus_Name);
+      ImmSetCompositionWindowProc =
+	(IMMSETCOMPOSITIONWINDOWPROC)
+	GetProcAddress (hImm32,
+			ImmSetCompositionWindow_Name);
+      ImmGetContextProc =
+	(IMMGETCONTEXTPROC)
+	GetProcAddress (hImm32,
+			ImmGetContext_Name);
+      ImmGetConversionStatusProc =
+	(IMMGETCONVERSIONSTATUSPROC)
+	GetProcAddress (hImm32,
+			ImmGetConversionStatus_Name);
+      ImmSetConversionStatusProc =
+	(IMMSETCONVERSIONSTATUSPROC)
+	GetProcAddress (hImm32,
+			ImmSetConversionStatus_Name);
+      ImmNotifyIMEProc =
+	(IMMNOTIFYIMEPROC)
+	GetProcAddress (hImm32,
+			ImmNotifyIME_Name);
+      ImmReleaseContextProc =
+	(IMMRELEASECONTEXTPROC)
+	GetProcAddress (hImm32,
+			ImmReleaseContext_Name);
+      ImmCreateContextProc =
+	(IMMCREATECONTEXTPROC)
+	GetProcAddress (hImm32,
+			ImmCreateContext_Name);
+      ImmDestroyContextProc =
+	(IMMDESTROYCONTEXTPROC)
+	GetProcAddress (hImm32,
+			ImmDestroyContext_Name);
+      ImmAssociateContextProc =
+	(IMMASSOCIATECONTEXTPROC)
+	GetProcAddress (hImm32,
+			ImmAssociateContext_Name);
+      ImmGetHotKeyProc =
+	(IMMGETHOTKEYPROC)
+	GetProcAddress (hImm32,
+			ImmGetHotKey_Name);
+      ImmGetCompositionStringProc =
+	(IMMGETCOMPOSITIONSTRINGPROC)
+	GetProcAddress (hImm32, ImmGetCompositionString_Name);
+      ImmSetCompositionStringProc =
+	(IMMSETCOMPOSITIONSTRINGPROC)
+	GetProcAddress (hImm32, ImmSetCompositionString_Name);
+      ImmSetCompositionFontProc =
+	(IMMSETCOMPOSITIONFONTPROC)
+	GetProcAddress (hImm32, ImmSetCompositionFont_Name);
+      ImmGetConversionListProc =
+	(IMMGETCONVERSIONLISTPROC)
+	GetProcAddress (hImm32,
+			ImmGetConversionList_Name);
+      ImmConfigureIMEProc =
+	(IMMCONFIGUREIMEPROC)
+	GetProcAddress (hImm32,
+			ImmConfigureIME_Name);
+      ImmGetCandidateListProc =
+	(IMMGETCANDIDATELISTPROC)
+	GetProcAddress (hImm32,
+			ImmGetCandidateList_Name);
+      ImmGetCandidateListCountProc =
+	(IMMGETCANDIDATELISTCOUNTPROC)
+	GetProcAddress (hImm32,
+			ImmGetCandidateListCount_Name);
+
+      if (ImmGetOpenStatusProc &&
+	  ImmSetOpenStatusProc &&
+	  ImmSetCompositionWindowProc &&
+	  ImmGetCompositionStringProc &&
+	  ImmSetCompositionStringProc &&
+	  ImmSetCompositionFontProc &&
+	  ImmGetContextProc &&
+	  ImmGetConversionStatusProc &&
+	  ImmSetConversionStatusProc &&
+	  ImmGetConversionListProc &&
+	  ImmConfigureIMEProc &&
+	  ImmNotifyIMEProc &&
+	  ImmReleaseContextProc &&
+	  ImmCreateContextProc &&
+	  ImmDestroyContextProc &&
+	  ImmAssociateContextProc &&
+	  ImmGetCandidateListProc &&
+	  ImmGetCandidateListCountProc &&
+	  ImmGetHotKeyProc)
+	{
+	  fIME = TRUE;
+	  Vime_control = Qt;
+	}
+    }
+}
+
+/* From here, communication programs to make IME a conversion machine. */
+static HIMC
+immcontext (context)
+     Lisp_Object context;
+{
+  if (NUMBERP (context))
+    return agent[XFASTINT (context)].himc;
+  else
+    return (HIMC)((((unsigned long) XCAR (context)) << 16) |
+	          (((unsigned long) XCDR (context)) & 0xffff));
+}
+
+/*static*/ LRESULT CALLBACK
+conversion_agent_wndproc (HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
+/*     HWND hwnd;
+       UINT message;
+       WPARAM wparam;
+       LPARAM lparam; */
+{
+  HIMC himc, holdimc;
+
+  switch (message)
+    {
+    case WM_CREATE:
+      himc = (ImmCreateContextProc) ();
+      holdimc = (HIMC)((ImmAssociateContextProc) (hwnd, himc));
+      SetWindowLong (hwnd, 0, (LONG)himc);
+      SetWindowLong (hwnd, 4, (LONG)holdimc);
+      break;
+
+    case WM_DESTROY:
+      holdimc = (HIMC)GetWindowLong (hwnd, 4);
+      himc = (HIMC)(HIMC)((ImmAssociateContextProc) (hwnd, holdimc));
+      (ImmDestroyContextProc) (himc);
+      break;
+
+    case WM_MULE_IMM_SET_STATUS:
+      w32_set_ime_status (hwnd, (int) wparam);
+      break;
+
+    case WM_MULE_IMM_GET_STATUS:
+      return w32_get_ime_status (hwnd);
+
+    case WM_MULE_IMM_SET_MODE:
+      return w32_set_ime_mode (hwnd, (int) wparam, (int) lparam);
+
+#if 0
+    case WM_MULE_IMM_GET_COMPOSITION_STRING:
+      return w32_get_ime_composition_string (hwnd);
+#endif
+
+    default:
+      return DefWindowProc (hwnd, message, wparam, lparam);
+    }
+  return 0;
+}
+
+/*static*/ int
+initialize_conversion_agent ()
+{
+  int i;
+  WNDCLASS wc;
+
+  for (i = 0;i < MAX_CONVAGENT;i++)
+    {
+      agent[i].hwnd = 0;
+      agent[i].himc = 0;
+    }
+
+  wc.style	   = 0;
+  wc.lpfnWndProc   = conversion_agent_wndproc;
+  wc.cbClsExtra    = 0;
+  wc.cbWndExtra    = sizeof(long) * 2;
+  wc.hInstance     = hinst;
+  wc.hIcon	   = NULL;
+  wc.hCursor       = NULL;
+  wc.hbrBackground = NULL;
+  wc.lpszMenuName  = NULL;
+  wc.lpszClassName = CONVAGENT_CLASS;
+
+  if (!RegisterClass (&wc))
+    return 0;
+
+  return 1;
+}
+
+
+/*
+  Emacs Lisp function entries
+*/
+
+DEFUN ("ime-force-on", Fime_force_on, Sime_force_on, 0, 1, 0,
+       doc: /* Force status of IME open.  */)
+  (eventp)
+     Lisp_Object eventp;
+{
+  if (fIME && !NILP (Vime_control))
+    {
+      HIMC himc;
+      HWND hwnd;
+
+      if (!NILP (Fime_get_mode ()))
+	return Qnil;
+#ifdef HAVE_NTGUI
+      if (NILP (eventp))
+	IME_event_off_count++;
+      hwnd = FRAME_W32_WINDOW (SELECTED_FRAME ());
+#else
+      hwnd = hwndConsole;
+#endif
+      SendMessage (hwnd, WM_MULE_IMM_SET_STATUS, 1, 0);
+    }
+  return Qnil;
+}
+
+DEFUN ("ime-force-off", Fime_force_off, Sime_force_off, 0, 1, 0,
+       doc: /* Force status of IME close.  */)
+  (eventp)
+     Lisp_Object eventp;
+{
+  if (fIME && !NILP (Vime_control))
+    {
+      HIMC himc;
+      HWND hwnd;
+
+      if (NILP (Fime_get_mode ()))
+	return Qnil;
+#ifdef HAVE_NTGUI
+      if (NILP (eventp))
+	IME_event_off_count++;
+      hwnd = FRAME_W32_WINDOW (SELECTED_FRAME ());
+#else
+      hwnd = hwndConsole;
+#endif
+      SendMessage (hwnd, WM_MULE_IMM_SET_STATUS, 0, 0);
+    }
+  return Qnil;
+}
+
+DEFUN ("ime-get-mode", Fime_get_mode, Sime_get_mode, 0, 0, "",
+       doc: /* Get IME status.
+t means status of IME is open.  nil means it is close.  */)
+  ()
+{
+  if (fIME && !NILP (Vime_control))
+    {
+      HWND hwnd;
+      int result;
+      struct frame *f; //debug
+
+#ifdef HAVE_NTGUI
+      f = SELECTED_FRAME (); //debug
+      if( f->output_data.w32==0 ) return Qnil ;
+      hwnd = FRAME_W32_WINDOW (f) ; //SELECTED_FRAME ());
+#else
+      hwnd = hwndConsole;
+#endif
+      result = SendMessage (hwnd, WM_MULE_IMM_GET_STATUS, 0, 0);
+
+      return result ? Qt : Qnil;
+    }
+  else
+    return Qnil;
+}
+
+DEFUN ("w32-set-ime-mode",
+       Fw32_set_ime_mode,
+       Sw32_set_ime_mode, 1, 2, 0,
+       doc: /* Set IME mode to MODE. If FRAME is omitted, the selected frame is used.  */)
+  (mode, frame)
+     Lisp_Object mode, frame;
+{
+  struct frame *f;
+
+  if (NILP (frame))
+    {
+      f = SELECTED_FRAME ();
+    }
+  else
+    {
+      CHECK_FRAME (frame);
+      f = XFRAME (frame);
+    }
+  if (fIME && !NILP (Vime_control))
+    {
+      HWND hwnd;
+      int ret;
+      int newmode, mask;
+
+      newmode = 0;
+      mask = 0;
+
+      hwnd = FRAME_W32_WINDOW (f);
+
+      if (EQ (mode, intern ("katakana")))
+	{
+	  newmode |= IME_CMODE_KATAKANA;
+	  mask |= IME_CMODE_KATAKANA;
+	}
+      else if (EQ (mode, intern ("hiragana")))
+	{
+	  newmode &= ~IME_CMODE_KATAKANA;
+	  mask |= IME_CMODE_KATAKANA;
+	}
+      else if (EQ (mode, intern ("kanji")))
+	{
+	  newmode |= IME_CMODE_HANJACONVERT;
+	  mask |= IME_CMODE_HANJACONVERT;
+	}
+      else if (EQ (mode, intern ("nokanji")))
+	{
+	  newmode &= ~IME_CMODE_HANJACONVERT;
+	  mask |= IME_CMODE_HANJACONVERT;
+	}
+      else if (EQ (mode, intern ("code")))
+	{
+	  newmode |= IME_CMODE_CHARCODE;
+	  mask |= IME_CMODE_CHARCODE;
+	}
+      else if (EQ (mode, intern ("nocode")))
+	{
+	  newmode &= ~IME_CMODE_CHARCODE;
+	  mask |= IME_CMODE_CHARCODE;
+	}
+      else if (EQ (mode, intern ("non-convert")))
+	{
+	  newmode |= IME_CMODE_NOCONVERSION;
+	  mask |= IME_CMODE_NOCONVERSION;
+	}
+      else if (EQ (mode, intern ("convert")))
+	{
+	  newmode &= ~IME_CMODE_NOCONVERSION;
+	  mask |= IME_CMODE_NOCONVERSION;
+	}
+      else
+	error ("unknown mode!!");
+
+      ret = SendMessage (hwnd, WM_MULE_IMM_SET_MODE,
+			 (WPARAM) newmode, (LPARAM) mask);
+
+      if (!ret)
+	return Qnil;
+
+      return Qt;
+    }
+  return Qnil;
+}
+
+DEFUN ("w32-ime-register-word-dialog",
+       Fw32_ime_register_word_dialog,
+       Sw32_ime_register_word_dialog, 2, 2, 0,
+       doc: /* Open IME regist word dialog.  */)
+  (reading, word)
+     Lisp_Object reading, word;
+{
+  HKL hkl;
+  int reading_len, word_len;
+  REGISTERWORD regword;
+  Lisp_Object encoded_reading, encoded_word;
+
+  CHECK_STRING (reading);
+  CHECK_STRING (word);
+
+  if (fIME && !NILP (Vime_control) && ImmConfigureIMEProc)
+    {
+      hkl = GetKeyboardLayout (0);
+      encoded_reading = Fencode_coding_string (reading,
+					       Vlocale_coding_system,
+					       Qnil, Qnil);
+      reading_len = SBYTES (encoded_reading);
+      regword.lpReading = SDATA (encoded_reading);
+
+      encoded_word = Fencode_coding_string (word,
+					    Vlocale_coding_system,
+					    Qnil, Qnil);
+      word_len = SBYTES (encoded_word);
+      regword.lpWord = SDATA (encoded_word);
+      (ImmConfigureIMEProc) (hkl, FRAME_W32_WINDOW (SELECTED_FRAME ()),
+			    IME_CONFIG_REGISTERWORD, &regword);
+    }
+  return Qnil;
+}
+#endif /* USE_W32_IME */
+
+
 /***********************************************************************
 			 w32 specialized functions
  ***********************************************************************/
@@ -10379,6 +11516,9 @@
   x_set_fullscreen,
   x_set_font_backend,
   x_set_alpha,
+#ifdef USE_W32_IME
+  0,
+#endif /* USE_W32_IME */
   0, /* x_set_sticky */
   0, /* x_set_tool_bar_position */
   0, /* x_set_inhibit_double_buffering */
@@ -10401,6 +11541,9 @@
   w32_visible_system_caret_hwnd = NULL;
 
   DEFSYM (Qundefined_color, "undefined-color");
+#ifdef USE_W32_IME
+  DEFSYM (Qime_font, "ime-font");
+#endif /* USE_W32_IME */
   DEFSYM (Qcancel_timer, "cancel-timer");
   DEFSYM (Qhyper, "hyper");
   DEFSYM (Qsuper, "super");
@@ -10747,6 +11890,17 @@
 	       doc: /* Non-nil means don't display the abort dialog when aborting.  */);
   w32_disable_abort_dialog = 0;
 
+#ifdef USE_W32_IME
+  DEFVAR_LISP ("ime-control", Vime_control, "IME control flag");
+  Vime_control = Qnil;
+
+  DEFVAR_LISP ("w32-ime-composition-window",
+	       Vw32_ime_composition_window,
+	       doc: /* If this is a window of current frame, IME composition window appears on the
+window instead of current window.  */);
+  Vw32_ime_composition_window = Qnil;
+#endif /* USE_W32_IME */
+
 #if 0 /* TODO: Port to W32 */
   defsubr (&Sx_change_window_property);
   defsubr (&Sx_delete_window_property);
@@ -10801,6 +11955,14 @@
   defsubr (&Sw32_notification_close);
 #endif
 
+#ifdef USE_W32_IME
+  defsubr (&Sw32_set_ime_mode);
+  defsubr (&Sw32_ime_register_word_dialog);
+  defsubr (&Sime_force_on);
+  defsubr (&Sime_force_off);
+  defsubr (&Sime_get_mode);
+#endif /* USE_W32_IME */
+
 #ifdef WINDOWSNT
   defsubr (&Sfile_system_info);
   defsubr (&Sdefault_printer_name);
@@ -11076,6 +12238,7 @@
   get_title_bar_info_fn = (GetTitleBarInfo_Proc)
     GetProcAddress (user32_lib, "GetTitleBarInfo");
 
+#ifndef USE_W32_IME
   {
     HMODULE imm32_lib = GetModuleHandle ("imm32.dll");
     get_composition_string_fn = (ImmGetCompositionString_Proc)
@@ -11087,6 +12250,7 @@
     set_ime_composition_window_fn = (ImmSetCompositionWindow_Proc)
       GetProcAddress (imm32_lib, "ImmSetCompositionWindow");
   }
+#endif /* USE_W32_IME */
 
   except_code = 0;
   except_addr = 0;
diff -r -u emacs-26.3/src/w32font.c emacs-26.3/src/w32font.c
--- emacs-26.3/src/w32font.c	2019-01-07 23:26:07.000000000 +0900
+++ emacs-26.3/src/w32font.c	2019-08-29 22:10:56.490922200 +0900
@@ -52,7 +52,7 @@
 #define JOHAB_CHARSET 130
 #endif
 
-static void fill_in_logfont (struct frame *, LOGFONT *, Lisp_Object);
+void fill_in_logfont (struct frame *, LOGFONT *, Lisp_Object);
 
 static BYTE w32_antialias_type (Lisp_Object);
 static Lisp_Object lispy_antialias_type (BYTE);
@@ -1948,7 +1948,7 @@
 }
 
 /* Fill in all the available details of LOGFONT from FONT_SPEC.  */
-static void
+void
 fill_in_logfont (struct frame *f, LOGFONT *logfont, Lisp_Object font_spec)
 {
   Lisp_Object tmp, extra;
diff -r -u emacs-26.3/src/w32font.h emacs-26.3/src/w32font.h
--- emacs-26.3/src/w32font.h	2019-01-07 23:26:07.000000000 +0900
+++ emacs-26.3/src/w32font.h	2019-08-29 22:10:56.490922200 +0900
@@ -83,6 +83,7 @@
 int uniscribe_check_otf (LOGFONT *font, Lisp_Object otf_spec);
 
 Lisp_Object intern_font_name (char *);
+extern void fill_in_logfont (struct frame *f, LOGFONT *, Lisp_Object);
 
 extern void globals_of_w32font (void);
 
diff -r -u emacs-26.3/src/w32proc.c emacs-26.3/src/w32proc.c
--- emacs-26.3/src/w32proc.c	2019-01-07 23:26:07.000000000 +0900
+++ emacs-26.3/src/w32proc.c	2019-08-29 22:10:56.506579400 +0900
@@ -1910,7 +1910,10 @@
 
       if (*p == 0)
 	need_quotes = 1;
+/* patch20101016
       for ( ; *p; p++)
+*/
+      for ( ; *p; p = STRINC(p))
 	{
 	  if (escape_char == '"' && *p == '\\')
 	    /* If it's a Cygwin/MSYS app, \ needs to be escaped.  */
@@ -1962,7 +1965,10 @@
 
       if (do_quoting)
 	{
+/* patch20101016
 	  for ( ; *p; p++)
+*/
+	  for ( ; *p; p = STRINC(p))
 	    if ((strchr (sepchars, *p) != NULL) || *p == '"')
 	      need_quotes = 1;
 	}
@@ -1990,7 +1996,10 @@
 	      *parg++ = *p++;
 	    }
 #else
+/* patch20101016
 	  for ( ; *p; p++)
+*/
+	  for ( ; *p; )
 	    {
 	      if (*p == '"')
 		{
@@ -2005,12 +2014,19 @@
 		}
 	      else if (escape_char == '"' && *p == '\\')
 		*parg++ = '\\';
+/* patch20101016
 	      *parg++ = *p;
-
+*/
 	      if (*p == escape_char && escape_char != '"')
 		escape_char_run++;
 	      else
 		escape_char_run = 0;
+/* patch20101016 */
+	      {
+		char *px = STRINC(p);
+		while (px != p) *parg++ = *p++;
+	      }
+/* patch20101016 */
 	    }
 	  /* double escape chars before enclosing quote */
 	  while (escape_char_run > 0)
diff -r -u emacs-26.3/src/w32term.c emacs-26.3/src/w32term.c
--- emacs-26.3/src/w32term.c	2019-02-20 22:44:42.000000000 +0900
+++ emacs-26.3/src/w32term.c	2020-04-21 21:41:25.963145100 +0900
@@ -5151,6 +5151,12 @@
 	    }
 
 	  check_visibility = 1;
+#ifdef USE_W32_IME
+	  if (f && f == FRAME_DISPLAY_INFO (f)->x_highlight_frame
+	      && !NILP (Fime_get_mode ()))
+	    PostMessage (FRAME_W32_WINDOW (f),
+			 WM_MULE_IMM_SET_CONVERSION_WINDOW, (WPARAM) f, 0);
+#endif /* USE_W32_IME */
 	  break;
 
 	case WM_ACTIVATE:
@@ -5499,6 +5505,93 @@
 	  break;
 #endif
 
+#ifdef USE_W32_IME
+	case WM_MULE_IME_STATUS:
+	  f = x_window_to_frame (dpyinfo, msg.msg.hwnd);
+
+	  if (f && !f->iconified && f->visible)
+	    {
+	      inev.kind = NON_ASCII_KEYSTROKE_EVENT;
+	      inev.code = VK_KANJI;
+	      inev.modifiers = 0;
+	      XSETFRAME (inev.frame_or_window, f);
+	      inev.timestamp = msg.msg.time;
+	    }
+	  break;
+
+	case WM_MULE_IME_REPORT:
+	  {
+#ifdef IME_UNICODE
+	    LPWSTR lpStr;
+#else
+	    LPSTR lpStr;
+#endif
+	    struct input_event buf;
+	    HANDLE hw32_ime_string = (HANDLE) msg.msg.wParam;
+
+	    f = (struct frame *) msg.msg.lParam;
+	    if (f && !f->iconified && f->visible)
+	      {
+#ifdef IME_UNICODE
+		lpStr = (LPWSTR) hw32_ime_string;
+#else
+		lpStr = (LPSTR) hw32_ime_string;
+#endif
+		while(lpStr)
+		  {
+		    EVENT_INIT (buf);
+		    XSETFRAME (buf.frame_or_window, f);
+		    buf.timestamp = msg.msg.time;
+		    buf.modifiers = 0;
+		    if (*lpStr)
+		      {
+			if (*lpStr < 0x80)
+			  buf.kind = ASCII_KEYSTROKE_EVENT;
+			else
+			  buf.kind = MULTIBYTE_CHAR_KEYSTROKE_EVENT;
+#ifdef IME_UNICODE
+			if ((*lpStr & 0xFC00) == 0xD800
+			    && (*(lpStr + 1) & 0xFC00) == 0xDC00)
+			  {
+			    buf.code = 0x10000
+			      + (((*lpStr & 0x3FF) << 10)
+				 | *(lpStr + 1) & 0x3FF);
+			    lpStr++;
+			  }
+			else
+			  buf.code = *lpStr;
+#else
+			buf.code = *lpStr;
+#endif
+			kbd_buffer_store_event (&buf);
+			lpStr++;
+		      }
+		    else
+		      {
+			buf.kind = NON_ASCII_KEYSTROKE_EVENT;
+			buf.code = VK_COMPEND;
+			kbd_buffer_store_event (&buf);
+			break;
+		      }
+		  }
+		HeapFree (GetProcessHeap (), 0, (LPVOID) hw32_ime_string);
+	      }
+	  }
+	  break;
+
+	case WM_MULE_IME_DEL_RANGE:
+	  del_range (((int*)msg.msg.lParam)[0], ((int*)msg.msg.lParam)[1]);
+	  xfree ((int*)msg.msg.lParam);
+	  break;
+
+	case WM_MULE_IME_SET_FONT:
+	  {
+	    w32_set_ime_logfont (msg.msg.hwnd, (struct frame *) msg.msg.wParam);
+	    break;
+	  }
+
+#endif /* USE_W32_IME */
+
 	default:
 	  /* Check for messages registered at runtime.  */
 	  if (msg.msg.message == msh_mousewheel)
@@ -5866,6 +5959,12 @@
 
 	  PostMessage (hwnd, WM_IME_STARTCOMPOSITION, 0, 0);
 
+#ifdef USE_W32_IME
+	  if (f && f == FRAME_DISPLAY_INFO (f)->x_highlight_frame
+	      && !NILP (Fime_get_mode ()))
+	    PostMessage (hwnd, WM_MULE_IMM_SET_CONVERSION_WINDOW, (WPARAM) f, 0);
+#endif /* USE_W32_IME */
+
 	  /* If the size of the active cursor changed, destroy the old
 	     system caret.  */
 	  if (w32_system_caret_hwnd
@@ -7318,6 +7417,9 @@
     horizontal_scroll_bar_left_border = horizontal_scroll_bar_right_border
       = GetSystemMetrics (SM_CYHSCROLL);
   }
+#ifdef USE_W32_IME
+  w32_ime_control_init();
+#endif /* USE_W32_IME */
 }
 
 void
diff -r -u emacs-26.3/src/w32term.h emacs-26.3/src/w32term.h
--- emacs-26.3/src/w32term.h	2019-01-07 23:26:07.000000000 +0900
+++ emacs-26.3/src/w32term.h	2019-08-29 22:10:56.506579400 +0900
@@ -619,6 +619,8 @@
 #endif /* WM_MOUSEHWHEEL  */
 #ifndef WM_APPCOMMAND
 #define WM_APPCOMMAND 0x319
+#endif
+#ifndef GET_APPCOMMAND_LPARAM
 #define GET_APPCOMMAND_LPARAM(lParam)  (HIWORD(lParam) & 0x7fff)
 #endif
 #ifndef WM_UNICHAR
@@ -657,6 +659,93 @@
 #define WM_EMACS_FILENOTIFY            (WM_EMACS_START + 25)
 #define WM_EMACS_END                   (WM_EMACS_START + 26)
 
+#ifdef USE_W32_IME
+#ifndef VK_KANJI
+#define VK_KANJI 0x19
+#endif
+#ifndef VK_KANA
+#define VK_KANA  0x15
+#endif
+#define VK_COMPEND 0x1A
+
+#ifdef RECONVERSION
+#ifndef WM_IME_REQUEST
+#define WM_IME_REQUEST                  0x288
+#endif
+#ifndef IMR_COMPOSITIONWINDOW
+#define IMR_COMPOSITIONWINDOW           0x0001
+#endif
+#ifndef IMR_CANDIDATEWINDOW
+#define IMR_CANDIDATEWINDOW             0x0002
+#endif
+#ifdef IMR_COMPOSITIONFONT
+#define IMR_COMPOSITIONFONT             0x0003
+#endif
+#ifndef IMR_RECONVERTSTRING
+#define IMR_RECONVERTSTRING             0x0004
+#endif
+#ifndef IMR_CONFIRMRECONVERTSTRING
+#define IMR_CONFIRMRECONVERTSTRING      0x0005
+#endif
+#endif
+
+/* For internal communications
+   from window procedure to event loop. */
+#define WM_MULE_IME_REPORT         (WM_USER+2200)
+#define WM_MULE_IME_STATUS         (WM_USER+2201)
+#define WM_MULE_IME_DEL_RANGE      (WM_USER+2202)
+#define WM_MULE_IME_SET_FONT       (WM_USER+2203)
+
+/* For internal communications
+   from main thread to window procedure. */
+#define WM_MULE_IMM_MESSAGE_START             (WM_USER+2300)
+#define WM_MULE_IMM_SET_STATUS                (WM_USER+2300)
+#define WM_MULE_IMM_GET_STATUS                (WM_USER+2301)
+#if 0
+#define WM_MULE_IMM_DEAL_WITH_CONTEXT         (WM_USER+2302)
+#define WM_MULE_IMM_SET_COMPOSITION_STRING    (WM_USER+2303)
+#endif
+#define WM_MULE_IMM_GET_COMPOSITION_STRING    (WM_USER+2304)
+#define WM_MULE_IMM_SET_MODE                  (WM_USER+2305)
+#if 0
+#define WM_MULE_IMM_NOTIFY                    (WM_USER+2310)
+#define WM_MULE_IMM_GET_UNDETERMINED_STRING_LENGTH (WM_USER+2320)
+#endif
+#define WM_MULE_IMM_SET_IMEFONT		      (WM_USER+2311)
+#define WM_MULE_IMM_SET_CONVERSION_WINDOW      (WM_USER+2312)
+
+#define WM_MULE_IMM_PERFORM_RECONVERSION      (WM_USER+2320)
+
+#define WM_MULE_IMM_MESSAGE_END               (WM_USER+2399)
+#define MESSAGE_IMM_COM_P(message)              \
+  (((message) >= WM_MULE_IMM_MESSAGE_START) &&  \
+   ((message) <= WM_MULE_IMM_MESSAGE_END))
+
+#define CONVAGENT_CLASS "ConvAgent"
+
+
+#ifdef RECONVERSION
+#ifndef HAVE_RECONVERTSTRING
+typedef struct tagRECONVERTSTRING {
+  DWORD dwSize;
+  DWORD dwVersion;
+  DWORD dwStrLen;
+  DWORD dwStrOffset;
+  DWORD dwCompStrLen;
+  DWORD dwCompStrOffset;
+  DWORD dwTargetStrLen;
+  DWORD dwTargetStrOffset;
+} RECONVERTSTRING, *PRECONVERTSTRING;
+#endif
+#ifndef SCS_SETRECONVERTSTRING
+#define SCS_SETRECONVERTSTRING 0x00010000
+#endif
+#ifndef SCS_QUERYRECONVERTSTRING
+#define SCS_QUERYRECONVERTSTRING 0x00020000
+#endif
+#endif /* RECONVERSION */
+#endif /* USE_W32_IME */
+
 #define WND_FONTWIDTH_INDEX    (0)
 #define WND_LINEHEIGHT_INDEX   (4)
 #define WND_BORDER_INDEX       (8)
@@ -857,6 +946,23 @@
 extern Lisp_Object w32_popup_dialog (struct frame *, Lisp_Object, Lisp_Object);
 extern void w32_arrow_cursor (void);
 
+#ifdef NTGUI_UNICODE
+extern Lisp_Object ntgui_encode_system (Lisp_Object str);
+#define GUISTR(x) (L ## x)
+#define GUI_ENCODE_FILE GUI_ENCODE_SYSTEM
+#define GUI_ENCODE_SYSTEM(x) ntgui_encode_system (x)
+#define GUI_FN(fn) fn ## W
+typedef wchar_t guichar_t;
+#else /* !NTGUI_UNICODE */
+#define GUISTR(x) x
+#define GUI_ENCODE_FILE ENCODE_FILE
+#define GUI_ENCODE_SYSTEM ENCODE_SYSTEM
+#define GUI_FN(fn) fn
+typedef char guichar_t;
+#endif /* NTGUI_UNICODE */
+
+#define GUI_SDATA(x) ((guichar_t*) SDATA (x))
+
 extern void syms_of_w32term (void);
 extern void syms_of_w32menu (void);
 extern void syms_of_w32fns (void);
@@ -867,6 +973,9 @@
 
 extern void w32_init_main_thread (void);
 
+extern void w32_set_ime_logfont (HWND, struct frame *);
+extern void w32_ime_control_init (void);
+
 #ifdef CYGWIN
 extern int w32_message_fd;
 #endif /* CYGWIN */
diff -r -u emacs-26.3/src/window.c emacs-26.3/src/window.c
--- emacs-26.3/src/window.c	2019-06-12 19:50:42.000000000 +0900
+++ emacs-26.3/src/window.c	2019-08-29 22:10:56.522168200 +0900
@@ -478,6 +478,9 @@
 {
   struct window *w;
   struct frame *sf;
+#ifdef USE_W32_IME
+  Lisp_Object oldwin = selected_window;
+#endif /* USE_W32_IME */
 
   CHECK_LIVE_WINDOW (window);
 
@@ -531,6 +534,11 @@
       record_buffer (w->contents);
     }
 
+#ifdef USE_W32_IME
+  if (!NILP (Vselect_window_functions))
+     run_hook_with_args_2 (Qselect_window_functions, oldwin, window);
+#endif /* USE_W32_IME */
+
   return window;
 }
 
@@ -3613,6 +3621,12 @@
 
   set_window_buffer (window, buffer, true, !NILP (keep_margins));
 
+#ifdef USE_W32_IME
+  if (!NILP (Vset_selected_window_buffer_functions))
+    CALLN (Frun_hook_with_args, Qset_selected_window_buffer_functions,
+           tem, window, buffer);
+#endif /* USE_W32_IME */
+
   return Qnil;
 }
 
@@ -7576,6 +7590,10 @@
   Fput (Qscroll_down, Qscroll_command, Qt);
 
   DEFSYM (Qwindow_configuration_change_hook, "window-configuration-change-hook");
+#ifdef USE_W32_IME
+  DEFSYM (Qset_selected_window_buffer_functions, "set-selected-window-buffer-functions");
+  DEFSYM (Qselect_window_functions, "select-window-functions");
+#endif
   DEFSYM (Qwindowp, "windowp");
   DEFSYM (Qwindow_configuration_p, "window-configuration-p");
   DEFSYM (Qwindow_live_p, "window-live-p");
@@ -7678,6 +7696,17 @@
 functions on behalf of that as well.  */);
   Vwindow_size_change_functions = Qnil;
 
+#ifdef USE_W32_IME
+  DEFVAR_LISP ("set-selected-window-buffer-functions",
+               Vset_selected_window_buffer_functions,
+               doc: /* Functions to call when set-window-buffer is called.  */);
+  Vset_selected_window_buffer_functions = Qnil;
+
+  DEFVAR_LISP ("select-window-functions", Vselect_window_functions,
+               doc: /* Functions to call when select-window is called.  */);
+  Vselect_window_functions = Qnil;
+#endif
+
   DEFVAR_LISP ("recenter-redisplay", Vrecenter_redisplay,
 	       doc: /* Non-nil means `recenter' redraws entire frame.
 If this option is non-nil, then the `recenter' command with a nil
--- original/emacs-26.3/lisp/international/w32-ime.el	1970-01-01 09:00:00.000000000 +0900
+++ emacs-26.3/lisp/international/w32-ime.el	2020-04-29 00:17:15.027775000 +0900
@@ -0,0 +1,214 @@
+;;;;; w32-ime.el ---- Meadow features for NTEmacs.
+;;
+;;   Author H.Miyashita
+;;
+;;;;;
+
+(defgroup W32-IME nil
+  "w32-ime"
+  :group 'emacs)
+
+(defvar w32-last-selection nil
+  "It is stored the last data from Emacs.")
+
+;----------
+
+(defvar w32-ime-on-hook nil
+  "Functions to eval when IME is turned on at least.
+Even if IME state is not changed, these functiona are maybe called.")
+(defvar w32-ime-off-hook nil
+  "Functions to eval when IME is turned off at least.
+Even if IME state is not changed, these functiona are maybe called.")
+(defvar w32-ime-buffer-switch-p t
+  "If this variable is nil, IME control when buffer is switched is disabled.")
+(defvar w32-ime-show-mode-line t
+  "When t, mode line indicates IME state.")
+(defvar w32-ime-mode-line-state-indicator "[O]"
+  "This is shown at the mode line. It is regarded as state of ime.")
+(make-variable-buffer-local 'w32-ime-mode-line-state-indicator)
+(put 'w32-ime-mode-line-state-indicator 'permanent-local t)
+(defvar w32-ime-mode-line-state-indicator-list '("-" "[|]" "[O]")
+  "List of IME state indicator string.")
+(defvar w32-ime-mode-line-format-original nil
+  "Original mode line format.")
+(defvar w32-ime-input-method-title nil
+  "String denoting W32-IME input method.")
+
+;;
+;; Section: IME
+;;
+
+;; ;; This is temporal solution.  In the future, we will prepare
+;; ;; dynamic configuration.
+;; (defvar w32-ime-coding-system-language-environment-alist
+;;   '(("Japanese" . japanese-shift-jis)
+;;     ("Chinese-GB" . chinese-iso-8bit)
+;;     ("Chinese-BIG5" . chinese-big5)
+;;     ("Korean" . korean-iso-8bit)))
+
+;;
+;; IME state indicator
+;;
+(global-set-key [kanji] 'ignore)
+(global-set-key [compend] 'ignore)
+
+(defun wrap-function-to-control-ime
+  (function interactive-p interactive-arg &optional suffix)
+  "Wrap FUNCTION, and IME control is enabled when FUNCTION is called.
+An original function is saved to FUNCTION-SUFFIX when suffix is string.
+If SUFFIX is nil, \"-original\" is added. "
+  (let ((original-function
+	 (intern (concat (symbol-name function)
+			 (if suffix suffix "-original")))))
+    (cond
+     ((not (fboundp original-function))
+      (fset original-function
+	    (symbol-function function))
+      (fset function
+	    (list
+	     'lambda '(&rest arguments)
+	     (when interactive-p
+	       (list 'interactive interactive-arg))
+	     `(cond
+		((and (ime-get-mode)
+		      (equal current-input-method "W32-IME"))
+ 		 (ime-force-off)
+		 (unwind-protect
+		     (apply ',original-function arguments)
+		   (when (and (not (ime-get-mode))
+			      (equal current-input-method "W32-IME"))
+		     (ime-force-on))))
+		(t
+		 (apply ',original-function arguments)))))))))
+
+(defvar w32-ime-toroku-region-yomigana nil
+  "* if this variable is string, toroku-region regard this value as yomigana.")
+
+(defun w32-ime-toroku-region (begin end)
+  (interactive "r")
+  (let ((string (buffer-substring begin end))
+	(w32-ime-buffer-switch-p nil)
+	(reading w32-ime-toroku-region-yomigana))
+    (unless (stringp reading)
+      (w32-set-ime-mode 'hiragana)
+      (setq reading
+	    (read-multilingual-string
+            (format "Input reading of \"%s\": " string) nil "W32-IME")))
+    (w32-ime-register-word-dialog reading string)))
+
+;; for IME management system.
+
+(defun w32-ime-sync-state (window)
+  (if w32-ime-buffer-switch-p
+      (progn
+	(with-current-buffer (window-buffer window)
+	  (let* ((frame (window-frame window))
+		 (ime-state (ime-get-mode)))
+	    (cond
+	     ((and (not ime-state)
+		   (equal current-input-method "W32-IME"))
+	      (ime-force-on nil)
+	      (run-hooks 'w32-ime-on-hook))
+	     ((and ime-state
+		   (not (equal current-input-method "W32-IME")))
+	      (ime-force-off nil)
+	      (run-hooks 'w32-ime-off-hook))))))
+    (progn
+      (dolist (win (window-list))
+	(with-current-buffer (window-buffer win)
+	  (w32-ime-mode-line-update))))
+    ))
+
+(defun w32-ime-set-selected-window-buffer-hook (oldbuf newwin newbuf)
+  (w32-ime-sync-state newwin))
+
+(defun w32-ime-select-window-hook (old new)
+  (w32-ime-sync-state new))
+
+(defun w32-ime-mode-line-update ()
+  (if (featurep 'w32-ime)
+      (progn
+        (cond
+         (w32-ime-show-mode-line
+          (unless (window-minibuffer-p (selected-window))
+            (setq w32-ime-mode-line-state-indicator
+                  (nth (if (ime-get-mode) 1 2)
+                       w32-ime-mode-line-state-indicator-list))))
+         (t
+          (setq w32-ime-mode-line-state-indicator
+                (nth 0 w32-ime-mode-line-state-indicator-list))))
+        (force-mode-line-update))
+    ))
+
+(defun w32-ime-init-mode-line-display ()
+  (unless (member 'w32-ime-mode-line-state-indicator mode-line-format)
+    (setq w32-ime-mode-line-format-original
+	  (default-value 'mode-line-format))
+    (if (and (stringp (car mode-line-format))
+	     (string= (car mode-line-format) "-"))
+	(setq-default mode-line-format
+		      (cons ""
+			    (cons 'w32-ime-mode-line-state-indicator
+				  (cdr mode-line-format))))
+      (setq-default mode-line-format
+		    (cons ""
+			  (cons 'w32-ime-mode-line-state-indicator
+				mode-line-format))))
+    (force-mode-line-update t)))
+
+(defun w32-ime-initialize ()
+   (when (and (or (eq system-type 'windows-nt) (eq system-type 'cygwin))
+	      (eq window-system 'w32)
+	      (featurep 'w32-ime))
+     (w32-ime-init-mode-line-display)
+     (w32-ime-mode-line-update)
+     (add-hook 'select-window-functions
+	       'w32-ime-select-window-hook)
+     (add-hook 'set-selected-window-buffer-functions
+	       'w32-ime-set-selected-window-buffer-hook)
+     (define-key global-map [kanji] 'toggle-input-method)))
+;;     (set-keyboard-coding-system 'utf-8)))
+
+(defun w32-ime-uninitialize ()
+  (when (and (or (eq system-type 'windows-nt) (eq system-type 'cygwin))
+	     (eq window-system 'w32)
+	     (featurep 'w32-ime))
+    (setq-default mode-line-format
+		  w32-ime-mode-line-format-original)
+    (force-mode-line-update t)
+    (remove-hook 'select-window-functions
+		 'w32-ime-select-window-hook)
+    (remove-hook 'set-selected-window-buffer-functions
+		 'w32-ime-set-selected-window-buffer-hook)
+    (define-key global-map [kanji] 'ignore)))
+
+(defun w32-ime-exit-from-minibuffer ()
+  (deactivate-input-method)
+  (when (<= (minibuffer-depth) 1)
+    (remove-hook 'minibuffer-exit-hook 'w32-ime-exit-from-minibuffer)))
+
+(defun w32-ime-state-switch (&optional arg)
+  (if arg
+      (progn
+	(setq deactivate-current-input-method-function
+	      'w32-ime-state-switch)
+	(run-hooks 'input-method-activate-hook)
+	(run-hooks 'w32-ime-on-hook)
+	(setq describe-current-input-method-function nil)
+	(when (eq (selected-window) (minibuffer-window))
+	  (add-hook 'minibuffer-exit-hook 'w32-ime-exit-from-minibuffer))
+	(ime-force-on)
+        (setq current-input-method-title w32-ime-input-method-title))
+    (setq current-input-method nil)
+    (run-hooks 'input-method-deactivate-hook)
+    (run-hooks 'w32-ime-off-hook)
+    (setq describe-current-input-method-function nil)
+    (ime-force-off)
+    (setq current-input-method-title nil))
+  (w32-ime-mode-line-update))
+
+(register-input-method "W32-IME" "Japanese" 'w32-ime-state-switch ""
+		       "W32 System IME")
+
+(if (symbol-function 'ime-get-mode)
+    (provide 'w32-ime))
